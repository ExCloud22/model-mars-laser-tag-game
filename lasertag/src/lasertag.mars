model lasertag

grid-layer Battleground as battleground

enum stance {
	Standing, Kneeling, Lying
}

agent green on Battleground{
	observe var energy : integer = 100
	observe var actionPoints : integer = 10
	observe var currStance = stance.Standing
	observe var movementRange : integer = 6 
	observe var movementPoints : integer = 6 
	observe var inGame : bool = true
	observe var wasTagged : bool = false
	observe var tagged : bool = false
	observe var magazineCount : integer = 5
	observe var visualRange : real = 2
	observe var visibility : real = 10
	//TODO: Liste der richtigen Feinde. Benötigen wir verschiedene agents?
	var enemyList : Tuple<List<red>,[blue],[yellow]>
	var teamList : [green]
	var wallList : List<Tuple<real, real>>
	var redList = new List<red>
	
	initialize {
		// pos at #(random(battleground.DimensionX),random(battleground.DimensionY)) 
		pos at #(1,4) 
	}
	
	tick {
		
		change_stance(stance.Kneeling)
		move_me("up")	
		
		
		// var tuple : Tuple<integer, integer> = #(2, 3)
		//enemyList.Add(#(xcor, ycor))
		
		//enemy_x = enemyList.Get(0).Item1
		//enemy_y = enemyList.Get(0).Item2
		//explore_env()
		refill_action_points()
	}	
	def move_me(direction : string) {
		if (movementPoints > 0) {
			switch (direction) {
				case "up" : { 
					if ((battleground.GetIntegerValue(xcor, ycor+1) === 0)) {
						battleground.SetIntegerValue(xcor, ycor, 0)
						move 1 up
						battleground.SetIntegerValue(xcor, ycor, 2)
						movementPoints = movementPoints -1
					}
				} // north
				case "up-right" : { 
					if ((battleground.GetIntegerValue(xcor+1, ycor+1) === 0)) {
						battleground.SetIntegerValue(xcor, ycor, 0)
						move 1 up-right
						battleground.SetIntegerValue(xcor, ycor, 2)
						movementPoints = movementPoints -1
					}
				} // north-east
				case "right" : { 
					if ((battleground.GetIntegerValue(xcor+1, ycor) === 0)) {
						battleground.SetIntegerValue(xcor, ycor, 0)
						move 1 right
						battleground.SetIntegerValue(xcor, ycor, 2)
						movementPoints = movementPoints -1
					}
				} // east
				case "down-right" : { 
					if ((battleground.GetIntegerValue(xcor+1, ycor-1) === 0)) {
						battleground.SetIntegerValue(xcor, ycor, 0)
						move 1 down-right
						battleground.SetIntegerValue(xcor, ycor, 2)
						movementPoints = movementPoints -1
					}
				} // south-east
				case "down" : { 
					if ((battleground.GetIntegerValue(xcor, ycor-1) === 0)) {
						battleground.SetIntegerValue(xcor, ycor, 0)
						move 1 down
						battleground.SetIntegerValue(xcor, ycor, 2)
						movementPoints = movementPoints -1
					}
				} // south
				case "down-left" : { 
					if ((battleground.GetIntegerValue(xcor-1, ycor-1) === 0)) {
						battleground.SetIntegerValue(xcor, ycor, 0)
						move 1 down-left
						battleground.SetIntegerValue(xcor, ycor, 2)
						movementPoints = movementPoints -1
					}
				} // south-west
				case "left" : { 
					if ((battleground.GetIntegerValue(xcor-1, ycor) === 0)) {
						battleground.SetIntegerValue(xcor, ycor, 0)
						move 1 left
						battleground.SetIntegerValue(xcor, ycor, 2)
						movementPoints = movementPoints -1
					}
				} // west
				case "up-left" : { 
					if ((battleground.GetIntegerValue(xcor-1, ycor+1) === 0)) {
						battleground.SetIntegerValue(xcor, ycor, 0)
						move 1 up-left
						battleground.SetIntegerValue(xcor, ycor, 2)
						movementPoints = movementPoints -1
					}
				} // north-west
			}
		
		}
	}
	
	// TODO: Andere Lösung zum auffüllen der Punkte finden
	def refill_action_points(){
		actionPoints = 10
		movementPoints = movementRange
	}
	
	//TODO: Punkte müssen zentral verwaltet werden
	// Wenn genug Punkte vorhanden wird die Position geändert (Kosten 2 Punkte)
	def change_stance(newStance : stance) {
		if (actionPoints < 2) {
			return
		}
		currStance = newStance
		actionPoints = actionPoints - 2
		switch (currStance) {
			case stance.Standing: {
				visualRange = 10
				visibility = 10
				movementRange = 6
			}
			case stance.Kneeling: {
				visualRange = 8
				visibility = 8
				movementRange = 3
			}
			case stance.Lying: {
				visualRange = 5
				visibility = 5
				movementRange = 1
			}
		}
	}
	def explore_env() {
		explore_team()
		//explore_enemies()
		explore_walls()
		
	}
	def explore_walls(){
		// Speichert alle in visualRange befindlichen Wände in wallList
		wallList = new List<Tuple<real, real>>
		for(var x = xcor - visualRange; x <= xcor + visualRange; x++){
			for(var y = ycor + visualRange; y >= ycor - visualRange; y--){
				if (battleground.GetIntegerValue(x,y) === 1) {
					wallList.Add(#(x,y))
					println #(x,y)
				}
				
			}
		}
	}
	def explore_team(){
		// Aktualisiert die Teammitglieder-Liste
		teamList = explore green
	}
	// TODO: Gegnerposition an Team automatisch weitergeben
	def explore_enemies(){
		// Agenten werden hinzugefügt wenn sie in Sichtweite sind
		var tmpRed = explore red where [x => return (distance x) <= visualRange and (distance x) <= x.GetVisibility]
		var tmpBlue = explore blue where [x => return (distance x) <= visualRange and (distance x) <= x.GetVisibility]
		var tmpYellow = explore yellow where [x => return (distance x) <= visualRange and (distance x) <= x.GetVisibility]
		// TODO: redList = new List<red>()
		// (Blockiert, meine Stellung, Gegner Stellung)
		// TODO: Blockierung durch Env. prüfen
		each (red in tmpRed) {
			// Enemy Vertikal von mir
			if (xcor === red.GetX) {
				// Enemy unter mir
				if (ycor > red.GetY) {
					each (wall in wallList) {
						// Keine Wand zwischen enemy und mir
						if (not(wall.Item1 === xcor and wall.Item2 > red.GetY and wall.Item2 < ycor)) {
							redList.Add(red)
						}
					}
				}
				// Enemy über mir
				if (ycor < red.GetY) {
					each (wall in wallList) {
						// Keine Wand zwischen enemy und mir
						if (not(wall.Item1 === xcor and wall.Item2 < red.GetY and wall.Item2 > ycor)) {
							redList.Add(red)
						}
					}
				}
			// Enemy Horizontal von mir
			}else if (ycor === red.GetY) {
				// Enemy Links von mir
				if (xcor > red.GetX) {
					each (wall in wallList) {
						// Keine Wand zwischen enemy und mir
						if (not(wall.Item2 === ycor and wall.Item1 > red.GetX and wall.Item1 < xcor)) {
							redList.Add(red)
						}
					}
				}
				// Enemy Rechts von mir
				if (xcor < red.GetX) {
					each (wall in wallList) {
						// Keine Wand zwischen enemy und mir
						if (not(wall.Item2 === ycor and wall.Item1 < red.GetX and wall.Item1 > xcor)) {
							redList.Add(red)
						}
					}
				}
				
			} else {
				
			}
		}
		enemyList = #(redList, tmpBlue, tmpYellow)
	}
//	def move_me(x_cor : real, y_cor : real) {
//		// TODO: bei Hindernis Verhalten festlegen
//		switch (movementRange) {
//			// im liegenden Zustand
//			case 1 : { 
//				if (battleground.GetIntegerValue(x_cor, y_cor) === 0) {
//					if (not(x_cor < (xcor -1) or x_cor > (xcor +1) or y_cor < (ycor -1) or y_cor > (ycor +1))) {
//						battleground.SetIntegerValue(xcor, ycor, 0)
//						move me to #(x_cor, y_cor)
//						battleground.SetIntegerValue(xcor, ycor, 2)
//					}
//				}
//			}
//			// im knienden Zustand
//			case 3 : { 
//				if (not(x_cor < (xcor -3) or x_cor > (xcor +3) or y_cor < (ycor -3) or y_cor > (ycor +3))) {
//					println "Ziel in Reichweite"
//					// Ziel ist Vertikal zu mir
//					if (xcor === x_cor) {
//						println "xcor === x_cor"
//						// Ziel ist unter mir
//						if (ycor > y_cor) {
//							println "ycor > y_cor"
//							var i = ycor-1
//							while(i >= y_cor){
//								println "prüfe: " + xcor + "," + i
//								if ((battleground.GetIntegerValue(xcor, i) === 1) or (battleground.GetIntegerValue(xcor, i) === 2)){
//									println "Hindernis auf: " + xcor + "," + i
//									battleground.SetIntegerValue(xcor, ycor, 0)
//									move me i+1 to #(x_cor, y_cor)
//									battleground.SetIntegerValue(xcor, ycor, 2)
//									return
//								}
//								i--
//							}
//							println "Bewege mich nach: " + x_cor + "," + y_cor
//							battleground.SetIntegerValue(xcor, ycor, 0)
//							move me movementRange to #(x_cor, y_cor)
//							battleground.SetIntegerValue(xcor, ycor, 2)
//						// Ziel ist über mir
//						}else {
//							var i = ycor+1
//							while(i <= y_cor){
//								if ((battleground.GetIntegerValue(xcor, i) === 1) or (battleground.GetIntegerValue(xcor, i) === 2)){
//									battleground.SetIntegerValue(xcor, ycor, 0)
//									move me i-1 to #(x_cor, y_cor)
//									battleground.SetIntegerValue(xcor, ycor, 2)
//									return
//								}
//								i++
//							}
//							battleground.SetIntegerValue(xcor, ycor, 0)
//							move me movementRange to #(x_cor, y_cor)
//							battleground.SetIntegerValue(xcor, ycor, 2)
//						}
//					}
//					
//				}
//			}
//			case 6 : { move 1 right}
//		}
//	}
	def shoot(){
		
	}
	passive GetVisibility() : real {
		return visibility
	}
	passive GetX() : real {
		return xcor
	}
	passive GetY() : real {
		return ycor
	}
}

agent red on Battleground {
	observe var energy : integer = 100
	observe var actionPoints : integer = 10
	observe var currStance = stance.Standing
	observe var inGame : bool = true
	observe var wasTagged : bool = false
	observe var tagged : bool = false
	observe var magazineCount : integer = 5
	observe var visualRange : real = 10
	observe var visibility : real = 10
	//TODO: Liste der richtigen Feinde. Benötigen wir verschiedene agents?
	var enemyList : Tuple<[green],[blue],[yellow]> = nil
	var teamList = new List<red>()
	observe var targetDistance : real
	
	initialize {
		pos at #(3,1) 
	}
	
	tick {
		//random_walk()	
		change_stance(stance.Kneeling)	
		
		refill_action_points()
	}	
	def refill_action_points(){
		actionPoints = 10
	}
	
	//TODO: Punkte müssen zentral verwaltet werden
	// Wenn genug Punkte vorhanden wird die Position geändert (Kosten 2 Punkte)
	def change_stance(newStance : stance) {
		if (actionPoints < 2) {
			return
		}
		currStance = newStance
		actionPoints = actionPoints - 2
	}
	def random_walk() {
		switch (random(8)) {
			case 0 : { move 1 up} // north
			case 1 : { move 1 up-right} // north-east
			case 2 : { move 1 right} // east
			case 3 : { move 1 down-right} // south-east
			case 4 : { move 1 down} // south
			case 5 : { move 1 down-left} // south-west
			case 6 : { move 1 left} // west
			case 7 : { move 1 up-left} // north-west
		}
	}
	passive GetVisibility() : real {
		return visibility
	}
	passive GetX() : real {
		return xcor
	}
	passive GetY() : real {
		return ycor
	}
}

agent blue on Battleground {
	observe var energy : integer = 100
	observe var actionPoints : integer = 10
	observe var currStance = stance.Standing
	observe var inGame : bool = true
	observe var wasTagged : bool = false
	observe var tagged : bool = false
	observe var magazineCount : integer = 5
	observe var visualRange : real = 10
	observe var visibility : real = 10
	//TODO: Liste der richtigen Feinde. Benötigen wir verschiedene agents?
	var enemyList : Tuple<[red],[green],[yellow]> = nil
	var teamList = new List<blue>()
	observe var targetDistance : real
	
	initialize {
		pos at #(random(battleground.DimensionX),random(battleground.DimensionY)) 
	}
	
	tick {
		random_walk()	
		change_stance(stance.Kneeling)	
		
		refill_action_points()
	}	
	def refill_action_points(){
		actionPoints = 10
	}
	
	//TODO: Punkte müssen zentral verwaltet werden
	// Wenn genug Punkte vorhanden wird die Position geändert (Kosten 2 Punkte)
	def change_stance(newStance : stance) {
		if (actionPoints < 2) {
			return
		}
		currStance = newStance
		actionPoints = actionPoints - 2
	}
	def random_walk() {
		switch (random(8)) {
			case 0 : { move 1 up} // north
			case 1 : { move 1 up-right} // north-east
			case 2 : { move 1 right} // east
			case 3 : { move 1 down-right} // south-east
			case 4 : { move 1 down} // south
			case 5 : { move 1 down-left} // south-west
			case 6 : { move 1 left} // west
			case 7 : { move 1 up-left} // north-west
		}
	}
	passive GetVisibility() : real {
		return visibility
	}
}

agent yellow on Battleground {
	observe var energy : integer = 100
	observe var actionPoints : integer = 10
	observe var currStance = stance.Standing
	observe var inGame : bool = true
	observe var wasTagged : bool = false
	observe var tagged : bool = false
	observe var magazineCount : integer = 5
	observe var visualRange : real = 10
	observe var visibility : real = 10
	//TODO: Liste der richtigen Feinde. Benötigen wir verschiedene agents?
	var enemyList : Tuple<[red],[blue],[green]> = nil
	var teamList = new List<yellow>()
	observe var targetDistance : real
	
	initialize {
		pos at #(random(battleground.DimensionX),random(battleground.DimensionY)) 
	}
	
	tick {
		random_walk()	
		change_stance(stance.Kneeling)	
		
		refill_action_points()
	}	
	def refill_action_points(){
		actionPoints = 10
	}
	
	//TODO: Punkte müssen zentral verwaltet werden
	// Wenn genug Punkte vorhanden wird die Position geändert (Kosten 2 Punkte)
	def change_stance(newStance : stance) {
		if (actionPoints < 2) {
			return
		}
		currStance = newStance
		actionPoints = actionPoints - 2
	}
	def random_walk() {
		switch (random(8)) {
			case 0 : { move 1 up} // north
			case 1 : { move 1 up-right} // north-east
			case 2 : { move 1 right} // east
			case 3 : { move 1 down-right} // south-east
			case 4 : { move 1 down} // south
			case 5 : { move 1 down-left} // south-west
			case 6 : { move 1 left} // west
			case 7 : { move 1 up-left} // north-west
		}
	}
	passive GetVisibility() : real {
		return visibility
	}
}
