model lasertag

grid-layer Battleground as battleground

// Team green
agent green on Battleground {
	observe var energy : integer = 100
	observe var actionPoints : integer = 10
	// possible values: standing, kneeling, lying
	observe var currStance : string = "standing"
	observe var movementRange : integer = 6
	observe var movementPoints : integer = 6
	observe var inGame : bool = true
	observe var wasTagged : bool = false
	observe var tagged : bool = false
	observe var magazineCount : integer = 5
	observe var visualRange : real = 2
	observe var visibility : real = 10
	// TODO: fix enemy lists (explore_enemies method)
	var enemyList : Tuple<List<red>, [blue], [yellow]>
	// TODO: change syntax to green[]?
	var teamList : [green]
	var wallList : List<Tuple<real, real>>
	var redList = new List<red>
	
	initialize {
		// pos at #(random(battleground.DimensionX),random(battleground.DimensionY)) 
		pos at #(1, 4) 
	}
	
	tick {
		change_stance("kneeling")
		move_me("up")	
		// var tuple : Tuple<integer, integer> = #(2, 3)
		//enemyList.Add(#(xcor, ycor))
		//enemy_x = enemyList.Get(0).Item1
		//enemy_y = enemyList.Get(0).Item2
		//explore_env()
		refill_points()
	}	
	
	// moves agent, if possible, one grid cell in the direction specified by the input parameter <direction>
	// TODO: implement a pathfinding algorithm (D*-algorithm?)
	def move_me(direction : string) {
		if (movementPoints < 1) {
			return
		}
		switch (direction) {
			case "up" : { 
				if ((battleground.GetIntegerValue(xcor, ycor + 1) === 0)) {
					battleground.SetIntegerValue(xcor, ycor, 0)
					move 1 up
					battleground.SetIntegerValue(xcor, ycor, 2)
					movementPoints = movementPoints - 1
				}
			}
			case "up-right" : { 
				if ((battleground.GetIntegerValue(xcor + 1, ycor + 1) === 0)) {
					battleground.SetIntegerValue(xcor, ycor, 0)
					move 1 up-right
					battleground.SetIntegerValue(xcor, ycor, 2)
					movementPoints = movementPoints - 1
				}
			}
			case "right" : { 
				if ((battleground.GetIntegerValue(xcor + 1, ycor) === 0)) {
					battleground.SetIntegerValue(xcor, ycor, 0)
					move 1 right
					battleground.SetIntegerValue(xcor, ycor, 2)
					movementPoints = movementPoints - 1
				}
			}
			case "down-right" : { 
				if ((battleground.GetIntegerValue(xcor + 1, ycor - 1) === 0)) {
					battleground.SetIntegerValue(xcor, ycor, 0)
					move 1 down-right
					battleground.SetIntegerValue(xcor, ycor, 2)
					movementPoints = movementPoints - 1
				}
			}
			case "down" : { 
				if ((battleground.GetIntegerValue(xcor, ycor - 1) === 0)) {
					battleground.SetIntegerValue(xcor, ycor, 0)
					move 1 down
					battleground.SetIntegerValue(xcor, ycor, 2)
					movementPoints = movementPoints - 1
				}
			}
			case "down-left" : { 
				if ((battleground.GetIntegerValue(xcor - 1, ycor - 1) === 0)) {
					battleground.SetIntegerValue(xcor, ycor, 0)
					move 1 down-left
					battleground.SetIntegerValue(xcor, ycor, 2)
					movementPoints = movementPoints - 1
				}
			}
			case "left" : { 
				if ((battleground.GetIntegerValue(xcor - 1, ycor) === 0)) {
					battleground.SetIntegerValue(xcor, ycor, 0)
					move 1 left
					battleground.SetIntegerValue(xcor, ycor, 2)
					movementPoints = movementPoints - 1
				}
			}
			case "up-left" : { 
				if ((battleground.GetIntegerValue(xcor - 1, ycor + 1) === 0)) {
					battleground.SetIntegerValue(xcor, ycor, 0)
					move 1 up-left
					battleground.SetIntegerValue(xcor, ycor, 2)
					movementPoints = movementPoints - 1
				}
			}
		}		
	}

	// refills actionPoints and movementPoints
	// TODO: consider designing different solution for refilling points (to avoid having to touch tick methods)
	def refill_points() {
		actionPoints = 10
		movementPoints = movementRange
	}
	
	// changes currStance to <newStance>
	def change_stance(newStance : string) {
		if (actionPoints < 2) {
			return
		}
		if (newStance === currStance) {
			return
		}
		currStance = newStance
		actionPoints = actionPoints - 2
		switch (currStance) {
			case "standing": {
				visualRange = 10
				visibility = 10
				movementRange = 6
			}
			case "kneeling": {
				visualRange = 8
				visibility = 8
				movementRange = 3
			}
			case "lying": {
				visualRange = 5
				visibility = 5
				movementRange = 1
			}
		}
	}
	
	// exploration of the environment occurs in three phases: 1) team members, 2) walls, 3) enemies
	def explore_env() {
		actionPoints = actionPoints - 1
		explore_team()
		explore_walls()
		//explore_enemies()
	}
	
	// generates a list of coordinates of all team members
	def explore_team() {
		teamList = explore green
	}
	
	// generates a list of coordinates within visualRange that contain a wall
	// TODO: fix exploration so that agent can't detect walls located behind walls (do cost-benefit analysis for this task)
	def explore_walls() {
		wallList = new List<Tuple<real, real>>
		for(var x = xcor - visualRange; x <= xcor + visualRange; x++) {
			for(var y = ycor + visualRange; y >= ycor - visualRange; y--) {
				if (battleground.GetIntegerValue(x,y) === 1) {
					wallList.Add(#(x,y))
					println #(x,y)
				}
			}
		}
	}
	
	// generates lists of coordinates of all enemies within visualRange
	// three conditions for being able to see an enemy:
		// 1) enemy coordinates are within visualRange
		// 2) enemy visibility makes enemy visible from my location
		// 3) there are no walls blocking linear vision between enemy and me
	// TODO: automatically forward enemy locations to other team members
	def explore_enemies() {
		// generate lists with enemies who satisfy conditions 1 and 2
		var tmpRed = explore red where [x => return (distance x) <= visualRange and (distance x) <= x.GetVisibility]
		var tmpBlue = explore blue where [x => return (distance x) <= visualRange and (distance x) <= x.GetVisibility]
		var tmpYellow = explore yellow where [x => return (distance x) <= visualRange and (distance x) <= x.GetVisibility]
		// redList = new List<red>()
		
		// TODO: for each enemy in list, check if condition 3 is is satisfied...
		// TODO: check whether a wall prevents agent from seeing enemy (implement linear vision)
		each (red in tmpRed) {
			// check if enemy is located vertically relative to me
			if (xcor === red.GetX) {
				// check if enemy is below me
				if (ycor > red.GetY) {
					each (wall in wallList) {
						// check if no wall between enemy and me
						if (not(wall.Item1 === xcor and wall.Item2 > red.GetY and wall.Item2 < ycor)) {
							redList.Add(red)
						}
					}
				}
				// check if enemy is above me
				if (ycor < red.GetY) {
					each (wall in wallList) {
						// check if no wall between me and enemy
						if (not(wall.Item1 === xcor and wall.Item2 < red.GetY and wall.Item2 > ycor)) {
							redList.Add(red)
						}
					}
				}
			// check if enemy is located horizontally relative to me
			} else if (ycor === red.GetY) {
				// check if enemy is located to my left
				if (xcor > red.GetX) {
					each (wall in wallList) {
						// check if no wall between enemy and me
						if (not(wall.Item2 === ycor and wall.Item1 > red.GetX and wall.Item1 < xcor)) {
							redList.Add(red)
						}
					}
				}
				// check if enemy is located to my right
				if (xcor < red.GetX) {
					each (wall in wallList) {
						// check if no wall between enemy and me
						if (not(wall.Item2 === ycor and wall.Item1 < red.GetX and wall.Item1 > xcor)) {
							redList.Add(red)
						}
					}
				}
			} else if (true) {
				// TODO: implement linear vision for enemies located diagonally relative to me
			} else {
				// TODO: implement linear vision for enemies with coordinates neither exactly vertical,
				// nor horizontal, nor diagonal relative to me
			}
		}
		enemyList = #(redList, tmpBlue, tmpYellow)
	}

	// tags an enemy whose coordinates are in enemyList
	def tag() {
		
	}
	
	// refills magazineCount
	def reload() {
		
	}
	
	// returns current visibility value to the caller
	passive GetVisibility() : real {
		return visibility
	}
	
	// TODO: consider combining GetX and GetY to one method and returning coordinates in a tuple
	// returns current x-coordinate to the caller
	passive GetX() : real {
		return xcor
	}
	
	// returns current y-coordinate to the caller
	passive GetY() : real {
		return ycor
	}
	
	// ignore this method for now
//	def move_me(x_cor : real, y_cor : real) {
//		switch (movementRange) {
//			case 1 : { 
//				if (battleground.GetIntegerValue(x_cor, y_cor) === 0) {
//					if (not(x_cor < (xcor - 1) or x_cor > (xcor + 1) or y_cor < (ycor - 1) or y_cor > (ycor + 1))) {
//						battleground.SetIntegerValue(xcor, ycor, 0)
//						move me to #(x_cor, y_cor)
//						battleground.SetIntegerValue(xcor, ycor, 2)
//					}
//				}
//			}
//			case 3 : { 
//				if (not(x_cor < (xcor - 3) or x_cor > (xcor + 3) or y_cor < (ycor - 3) or y_cor > (ycor + 3))) {
//					if (xcor === x_cor) {
//						if (ycor > y_cor) {
//							var i = ycor - 1
//							while(i >= y_cor) {
//								if ((battleground.GetIntegerValue(xcor, i) === 1) or (battleground.GetIntegerValue(xcor, i) === 2)) {
//									battleground.SetIntegerValue(xcor, ycor, 0)
//									move me i+1 to #(x_cor, y_cor)
//									battleground.SetIntegerValue(xcor, ycor, 2)
//									return
//								}
//								i--
//							}
//							battleground.SetIntegerValue(xcor, ycor, 0)
//							move me movementRange to #(x_cor, y_cor)
//							battleground.SetIntegerValue(xcor, ycor, 2)
//						} else {
//							var i = ycor + 1
//							while(i <= y_cor){
//								if ((battleground.GetIntegerValue(xcor, i) === 1) or (battleground.GetIntegerValue(xcor, i) === 2)) {
//									battleground.SetIntegerValue(xcor, ycor, 0)
//									move me i-1 to #(x_cor, y_cor)
//									battleground.SetIntegerValue(xcor, ycor, 2)
//									return
//								}
//								i++
//							}
//							battleground.SetIntegerValue(xcor, ycor, 0)
//							move me movementRange to #(x_cor, y_cor)
//							battleground.SetIntegerValue(xcor, ycor, 2)
//						}
//					}
//				}
//			}
//			case 6 : {move 1 right}
//		}
//	}
}

// Team red
agent red on Battleground {
	observe var energy : integer = 100
	observe var actionPoints : integer = 10
	observe var currStance : string = "standing"
	observe var inGame : bool = true
	observe var wasTagged : bool = false
	observe var tagged : bool = false
	observe var magazineCount : integer = 5
	observe var visualRange : real = 10
	observe var visibility : real = 10
	var enemyList : Tuple<[green], [blue], [yellow]> = nil
	var teamList = new List<red>()
	observe var targetDistance : real
	
	initialize {
		pos at #(3, 1) 
	}
	
	tick {
	
	}
	
	def refill_points() {
		actionPoints = 10
	}
	
	def change_stance(newStance : string) {
		if (actionPoints < 2) {
			return
		}
		currStance = newStance
		actionPoints = actionPoints - 2
	}
	def random_walk() {
		switch (random(8)) {
			case 0 : { move 1 up } // north
			case 1 : { move 1 up-right } // north-east
			case 2 : { move 1 right } // east
			case 3 : { move 1 down-right } // south-east
			case 4 : { move 1 down } // south
			case 5 : { move 1 down-left } // south-west
			case 6 : { move 1 left } // west
			case 7 : { move 1 up-left } // north-west
		}
	}
	
	passive GetVisibility() : real {
		return visibility
	}
	
	passive GetX() : real {
		return xcor
	}
	
	passive GetY() : real {
		return ycor
	}
}

// Team blue
agent blue on Battleground {
	observe var energy : integer = 100
	observe var actionPoints : integer = 10
	observe var currStance : string = "standing"
	observe var inGame : bool = true
	observe var wasTagged : bool = false
	observe var tagged : bool = false
	observe var magazineCount : integer = 5
	observe var visualRange : real = 10
	observe var visibility : real = 10
	var enemyList : Tuple<[red], [green], [yellow]> = nil
	var teamList = new List<blue>()
	observe var targetDistance : real
	
	initialize {
		pos at #(7, 2) 
	}
	
	tick {
	
	}	
	
	def refill_points() {
		actionPoints = 10
	}
	
	def change_stance(newStance : string) {
		if (actionPoints < 2) {
			return
		}
		currStance = newStance
		actionPoints = actionPoints - 2
	}

	def random_walk() {
		switch (random(8)) {
			case 0 : { move 1 up } // north
			case 1 : { move 1 up-right } // north-east
			case 2 : { move 1 right } // east
			case 3 : { move 1 down-right } // south-east
			case 4 : { move 1 down } // south
			case 5 : { move 1 down-left } // south-west
			case 6 : { move 1 left } // west
			case 7 : { move 1 up-left } // north-west
		}
	}

	passive GetVisibility() : real {
		return visibility
	}
}

// Team yellow
agent yellow on Battleground {
	observe var energy : integer = 100
	observe var actionPoints : integer = 10
	observe var currStance : string = "standing"
	observe var inGame : bool = true
	observe var wasTagged : bool = false
	observe var tagged : bool = false
	observe var magazineCount : integer = 5
	observe var visualRange : real = 10
	observe var visibility : real = 10
	var enemyList : Tuple<[red], [blue], [green]> = nil
	var teamList = new List<yellow>()
	observe var targetDistance : real
	
	initialize {
		pos at #(7, 1) 
	}
	
	tick {
	
	}
	
	def refill_points() {
		actionPoints = 10
	}
	
	def change_stance(newStance : string) {
		if (actionPoints < 2) {
			return
		}
		currStance = newStance
		actionPoints = actionPoints - 2
	}
	
	def random_walk() {
		switch (random(8)) {
			case 0 : { move 1 up } // north
			case 1 : { move 1 up-right } // north-east
			case 2 : { move 1 right } // east
			case 3 : { move 1 down-right } // south-east
			case 4 : { move 1 down } // south
			case 5 : { move 1 down-left } // south-west
			case 6 : { move 1 left } // west
			case 7 : { move 1 up-left } // north-west
		}
	}
	
	passive GetVisibility() : real {
		return visibility
	}
}
