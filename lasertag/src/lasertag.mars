model lasertag

use Mars

grid-layer Battleground as battleground

// Team green
agent Green on Battleground {
//	*********************** general attributes ***********************
	observe var xSpawn : real = 1.0
	observe var ySpawn : real = 1.0
	observe var color : string = "green"
	observe var energy : integer = 100
	observe var actionPoints : integer = 10
	observe var stage : integer = 0
	observe var points : integer = 0
//	*********************** movement attributes ***********************
	// values: standing, kneeling, lying
	observe var currStance : string = "standing"
	observe var movementDelay : integer = 0
	observe var hasMoved : bool = false
//	*********************** exploration attributes ***********************
	observe var visualRange : real = 10
	observe var visibilityRange : real = 10
	var barriers = new List<Tuple<real, real>>
	var hills = new List<Tuple<real, real>>
	var ditches = new List<Tuple<real, real>>
//	*********************** tagging attributes ***********************
	observe var magazineCount : integer = 5
	// TODO: define way to reset wasTagged and tagged
	observe var wasTagged : bool = false
	observe var wasTaggedCounter : integer = 0
	observe var tagged : bool = false
	observe var taggedCounter : integer = 0
//	*********************** pathfinding attributes ***********************
	var g : integer = 1000
	var rhs : integer = 1000
	var km : real = 0.0
	// tuple values: (<x>, <y>, <g>, <rhs>, <cost> <key1>, <key2>)
	var sStart : Tuple<real, real, integer, integer, integer, real, real>
	var sGoal : Tuple<real, real, integer, integer, integer, real, real>
	var sLast : Tuple<real, real, integer, integer, integer, real, real>
	var routeList = new List<Tuple<real, real, integer, integer, integer, real, real>>()
	var expandQueue = new List<Tuple<real, real, integer, integer, integer, real, real>>()
	var pathCalculated : bool = false
	
	initialize {
		pos at #(xSpawn, ySpawn)
	}
	
	tick {
		if (stage === 0) {
			goTo(22.0, 22.0)
			if ((xcor === 22.0) and (ycor === 22.0)) {
				stage = 1
				exploreHills()
				if (hills.Size() > 0) {
					goTo(hills.Get(0).Item1, hills.Get(0).Item2)
				}
			}
		}
		if (stage === 1) {
			goTo(hills.Get(0).Item1, hills.Get(0).Item2)
			if ((xcor === hills.Get(0).Item1) and (ycor === hills.Get(0).Item2)) {
				changeStance("lying")
				stage = 2
			}
		}
		if (stage === 2) {
			var enemies = exploreEnemies()
			if (length(enemies.Item1) > 0) {
				var red = enemies.Item1
				var r = red[0]
				tag(r)
			}
		}
		refillPoints()
	}

// **************************************************************************************** 
// ****************************** EXPLORATION AND VISION **********************************
// ****************************************************************************************
	
	// USER METHOD: exploration of environment
	// o: "barriers", "hills", "ditches"
	def exploreEnv(o : string) {
		if (actionPoints < 1) { return }
		switch (o) {
			case "barriers" : { exploreBarriers() }
			case "hills" : { exploreHills() }
			case "ditches" : { exploreDitches() }
		}
		actionPoints--
	}
	
	// generates a list of coordinates within visualRange that contain a wall
	def exploreBarriers() {
		var currBarriers = explore Barrier where [b => return ((distance b) <= visualRange and hasBeeline(xcor, ycor, b.GetX, b.GetY))]
		each (b in currBarriers) {
			var inList : bool = false
			each (e in barriers) {
				if ((e.Item1 === b.GetX) and (e.Item2 === b.GetY)) { inList = true }
			}			
			if (not inList) { barriers.Add(#(b.GetX, b.GetY)) }
		}
	}
	
	def exploreHills() {
		var currHills = explore Hill where [h => return ((distance h) <= visualRange and hasBeeline(xcor, ycor, h.GetX, h.GetY))]
		each (h in currHills) {
			var inList : bool = false
			each (e in hills) {
				if ((e.Item1 === h.GetX) and (e.Item2 === h.GetY)) { inList = true }
			}
			if (not inList) { hills.Add(#(h.GetX, h.GetY)) }
		}
	}
	
	def exploreDitches() {
		var currDitches = explore Ditch where [d => return ((distance d) <= visualRange and hasBeeline(xcor, ycor, d.GetX, d.GetY))]
		each (d in currDitches) {
			var inList : bool = false
			each (e in ditches) {
				if ((e.Item1 === d.GetX) and (e.Item2 === d.GetY)) { inList = true }
			}
			if (not inList) { ditches.Add(#(d.GetX, d.GetY)) }
		}
	}
	
	// USER METHOD: generates arrays of enemies who can be seen
	// three conditions for being able to see an enemy:
		// 1) enemy coordinates are within visualRange
		// 2) enemy visibility makes enemy visible from my location
		// 3) no walls blocking linear vision between enemy and me
	def exploreEnemies() : Tuple<Red[], Blue[], Yellow[]> {
		var enemies = #(explore Red where [x => return (actionPoints > 0) and (((distance x) <= visualRange) or (battleground.GetIntegerValue(xcor, ycor) === 3)) and (((distance x) <= x.GetVisibility) or (battleground.GetIntegerValue(xcor, ycor) === 2)) and hasBeeline(xcor, ycor, x.GetX, x.GetY)],
						explore Blue where [x => return (actionPoints > 0) and (((distance x) <= visualRange) or (battleground.GetIntegerValue(xcor, ycor) === 3)) and (((distance x) <= x.GetVisibility) or (battleground.GetIntegerValue(xcor, ycor) === 2)) and hasBeeline(xcor, ycor, x.GetX, x.GetY)],
						explore Yellow where [x => return (actionPoints > 0) and (((distance x) <= visualRange) or (battleground.GetIntegerValue(xcor, ycor) === 3)) and (((distance x) <= x.GetVisibility) or (battleground.GetIntegerValue(xcor, ycor) === 2)) and hasBeeline(xcor, ycor, x.GetX, x.GetY)]
						)
		if (actionPoints > 0) { actionPoints-- }
		return enemies
	}
	
	// implementation of Bresenham's Line Algorithm for obtaining a list of grid cells covered by a straight line between two points on the grid
	// http://tech-algorithm.com/articles/drawing-line-using-bresenham-algorithm/
	def hasBeeline(x1 : real, y1 : real, x2 : real, y2 : real) : bool {
	    var hasBeeline : bool = true
	    var x : integer = x1 as integer
	    var y : integer = y1 as integer
	    var newX2 : integer = x2 as integer
	    var newY2 : integer = y2 as integer
	    var w : integer = newX2 - x
	    var h : integer = newY2 - y
	    var dx1 : integer = 0
	    var dy1 : integer = 0
	    var dx2 : integer = 0
	    var dy2 : integer = 0
	    if (w < 0) { dx1 = -1 }
	    else if (w > 0) { dx1 = 1 }
	    if (h < 0) { dy1 = -1 }
	    else if (h > 0) { dy1 = 1 }
	    if (w < 0) { dx2 = -1 }
		else if (w > 0) { dx2 = 1 }
	    var longest : integer = Math.Abs(w)
	    var shortest : integer = Math.Abs(h)
	    if (not(longest > shortest)) {
	        longest = Math.Abs(h)
	        shortest = Math.Abs(w)
	        if (h < 0) { dy2 = -1 }
	    	else if (h > 0) { dy2 = 1 }
	        dx2 = 0          
	    }
	    var numerator : integer = longest / 2
	    for (var i=0; i < longest; i++) {
	        if ((battleground.GetIntegerValue(x as real, y as real) === 1) or (battleground.GetIntegerValue(x as real, y as real) === 2)) {
				hasBeeline = false
				return hasBeeline
			}
	        numerator = numerator + shortest
	        if (not (numerator < longest)) {
	            numerator = numerator - longest
	            x = x + dx1
	            y = y + dy1
	        } else {
	            x = x + dx2
	            y = y + dy2
	        }
	    }
	    return hasBeeline
	}
	
// **************************************************************************************** 
// *********************************** MOVEMENT BEGIN *************************************
// ****************************************************************************************
	
	// USER METHOD: main method for pathfinding and movement algorithm
	// implementation of modified D* Lite Algorithm for Agent pathfinding, movement, and path readjustment in case of unforeseen obstacles
	// xGoal: x-coordinate of grid cell Guest wants to move to
	// yGoal: y-coordinate of grid cell Guest wants to move to
	// return: boolean states if step was successfully taken
	// TODO: clean up movement (removeFromQueue unnecessary logic, code, methods)
	def goTo(xGoal : real, yGoal : real) : bool {
		if (battleground.GetIntegerValue(xGoal, yGoal) === 1) {
			hasMoved = true
			return false
		}
		if ((movementDelay > 0) or hasMoved or ((xGoal === xcor) and (yGoal === ycor))) { return false }
		// TODO: ist pathCalculated noch nötig?
		if (not pathCalculated) { initPathfinding(xGoal, yGoal) }
		sStart = findNextCell()
		var neighsInRouteList = findNeighsInRouteList()
		var neighsWithChangedCost = scanCostChanges(neighsInRouteList)
		if (neighsWithChangedCost.Size() !== 0) {
			// calculation of completely new path
			var newExpandQueue = new List<Tuple<real, real, integer, integer, integer, real, real>>
			expandQueue = newExpandQueue
			var newRouteList = new List<Tuple<real, real, integer, integer, integer, real, real>>
			routeList = newRouteList
			var keyInit = Math.Max(Math.Abs(xcor - xGoal), Math.Abs(ycor - yGoal))
			sGoal = #(xGoal, yGoal, g, 0, battleground.GetIntegerValue(xGoal, yGoal), keyInit, 0.0)
			expandQueue.Add(sGoal)
			km = 0.0
			sStart = #(xcor, ycor, g, rhs, battleground.GetIntegerValue(xcor, ycor), 1000.0, 1000.0)
			sLast = sStart
			computeShortestPath(sStart, km)
			sStart = findNextCell()
		}
		if (battleground.GetIntegerValue(sStart.Item1, sStart.Item2) === 2) {
			var hill = explore Hill where [h => return (h.GetX === sStart.Item1) and (h.GetY === sStart.Item2)]
			if (not hill[0].IsFree) {
				pathCalculated = false
				return false
			}
		} else if (battleground.GetIntegerValue(sStart.Item1, sStart.Item2) === 3) {
			var ditch = nearest Ditch where [d => return (d.GetX === sStart.Item1) and (d.GetY === sStart.Item2)]
			if (not ditch.IsFree) {
				pathCalculated = false
				return false
			}
		}
		moveMe(sStart.Item1, sStart.Item2)
		if ((xcor === sGoal.Item1) and (ycor === sGoal.Item2)) { pathCalculated = false	}
		return true
	}
	
	// computes initial route from (xcor, ycor) to (<xGoal>, <yGoal>)
	// xGoal: x-coordinate of grid cell Guest wants to move to
	// yGoal: y-coordinate of grid cell Guest wants to move to
	def initPathfinding(xGoal : real, yGoal : real) {
		var costSStart = battleground.GetIntegerValue(xcor, ycor)
		sStart = #(xcor, ycor, g, rhs, costSStart, 1000.0, 1000.0)
		sLast = sStart
		var keyInit = Math.Max(Math.Abs(xcor - xGoal), Math.Abs(ycor - yGoal))
		var costSGoal = battleground.GetIntegerValue(xGoal, yGoal)
		sGoal = #(xGoal, yGoal, g, 0, costSGoal, keyInit, 0.0)
		expandQueue = new List<Tuple<real, real, integer, integer, integer, real, real>>
		routeList = new List<Tuple<real, real, integer, integer, integer, real, real>>
		expandQueue.Add(sGoal)
		computeShortestPath(sStart, km)
		pathCalculated = true
	}
	
	// computes shortest path from current position to goal
	// sStart: tuple representing grid cell from which Guest starts moving towards goal
	// km: key modifier value
	def computeShortestPath(sStart : Tuple<real, real, integer, integer, integer, real, real>, km : real) {
		var u : Tuple<real, real, integer, integer, integer, real, real> = getTopKey()
		while ((u.Item6 !== 0.0) and ((u.Item6 < calcKey1(sStart, km)) or (sStart.Item4 > sStart.Item3))) {
			var kOld1 = u.Item6
			var kNew1 = calcKey1(u, km)
			var kNew2 = calcKey2(u)
			if (kOld1 < kNew1) {
				var v = #(u.Item1, u.Item2, u.Item3, u.Item4, u.Item5, kNew1, kNew2)
				updateQueue(u, v)
			} else if (u.Item3 > u.Item4) {
				var uNew = #(u.Item1, u.Item2, u.Item4, u.Item4, u.Item5, u.Item6, u.Item7)
				routeList.Add(uNew)
				var NeighList = Neigh(uNew)
				removeFromQueue(u)
				each (var s in NeighList) {
					if ((s.Item1 !== sGoal.Item1) or (s.Item2 !== sGoal.Item2)) {
						var newRHS = rhs(s, uNew)
						var sNew = #(s.Item1, s.Item2, s.Item3, newRHS, s.Item5, s.Item6, s.Item7)
						updateVertex(sNew, km)
					}
				}
			} else {
				var gOld = u.Item3
				var uNew = #(u.Item1, u.Item2, g, u.Item4, u.Item5, u.Item6, u.Item7)
				updateQueue(u, uNew)
				var neighList = Neigh(uNew)
				neighList.Add(uNew)
				each (var s in neighList) {
					var updated : bool = false
					if (s.Item4 === (u.Item5 + gOld)) {
						if ((s.Item1 !== sGoal.Item1) or (s.Item2 !== sGoal.Item2)) {
							var neighListTemp = Neigh(s)
							var newRHS = getMinRHS(s, neighListTemp)
							var newS = #(s.Item1, s.Item2, s.Item3, newRHS, s.Item5, s.Item6, s.Item7)
							updateVertex(newS, km)
							updated = true
						}
					}
					if (not updated) { updateVertex(s, km) }
				}
			}
			u = getTopKey()
		}
	}
	
	// determines which cell an Guest should move to next
	// return: tuple representing grid cell that Guest needs to move to
	def findNextCell() : Tuple<real, real, integer, integer, integer, real, real> {
		var nextCellCandidates = findNeighsInRouteList()
		var minNeigh = nextCellCandidates.Get(0)
		each (var neigh in nextCellCandidates) {
			if ((cost(neigh, sStart) + neigh.Item3) < (cost(minNeigh, sStart) + minNeigh.Item3)) {
				minNeigh = neigh
			} else if ((cost(neigh, sStart) + neigh.Item3) === (cost(minNeigh, sStart) + minNeigh.Item3)) {
				if ((xcor === neigh.Item1) or (ycor === neigh.Item2)) {
					minNeigh = neigh
				}
			}
		}
		return minNeigh
	}
	
	// creates a list of tuples representing grid cells that are neighbors of sStart and that are in routeList
	// return: list of tuples
	def findNeighsInRouteList() : List<Tuple<real, real, integer, integer, integer, real, real>> {
		var nextCellCandidates = new List<Tuple<real, real, integer, integer, integer, real, real>>()
		each (var s in routeList) {
			if (heur(sStart, s) === 1.0) {
				nextCellCandidates.Add(s)
			}
		}
		return nextCellCandidates
	}
  
	// determines for all elements of List if their cost is not equal to 1.
	// List: neighbors of sStart
	// return: list with neighbors of sStart that are in routeList and whose cost is not equal to 1
	def scanCostChanges(neighsinRouteList : List<Tuple<real, real, integer, integer, integer, real, real>>) : List<Tuple<real, real, integer, integer, integer, real, real>> {
		var currCostNeigh : integer
		var neighsWithChangedCost = new List<Tuple<real, real, integer, integer, integer, real, real>>()
		each(currNeigh in neighsinRouteList){
			currCostNeigh = cost(currNeigh, sStart)
			if (currCostNeigh !== currNeigh.Item5) {
				neighsWithChangedCost.Add(currNeigh)
			}
		}
		return neighsWithChangedCost
	}
	
	// obtains the next cell that should be examined during pathfinding
	// return: tuple with most favorable key1 and key2
	def getTopKey() : Tuple<real, real, integer, integer, integer, real, real> {
    	var minKey1 : real = expandQueue.Get(0).Item6
    	var minKey2 : real = expandQueue.Get(0).Item7
    	each (currElem in expandQueue) {
      		if (currElem.Item6 < minKey1) {
				minKey1 = currElem.Item6
				minKey2 = currElem.Item7
			} else if ((currElem.Item6 === minKey1) and (currElem.Item7 < minKey2)) {
				minKey2 = currElem.Item7
			}
		}
		var minKeyTuple : Tuple<real, real, integer, integer, integer, real, real>
		for (var i = 0; i < expandQueue.Size(); i++) {
			if ((expandQueue.Get(i).Item6 === minKey1) and (expandQueue.Get(i).Item7 === minKey2)) {
				minKeyTuple = expandQueue.Get(i)
				i = expandQueue.Size()
			}
		}
		return minKeyTuple
	}
	
	// calculates the first part of the key of a grid cell (using heuristic)
	// s: tuple for which key1 is to be calculated
	// km: key modifier value
	// return: key1 value of s
	def calcKey1(s : Tuple<real, real, integer, integer, integer, real, real>, km : real) : real {
		return Math.Min(s.Item3, s.Item4) + heur(sStart, s) + km
	}
	
	// heuristic: takes the larger value of the x-range and y-range between two grid cells
	// s1: tuple representing the first grid cell to be used in heuristic calculation
	// s2: tuple representing the second grid cell to be used in heuristic calculation
	// return: result of heuristic calculation
	def heur(s1 : Tuple<real, real, integer, integer, integer, real, real>, s2 : Tuple<real, real, integer, integer, integer, real, real>) : real {
		return Math.Max(Math.Abs(s1.Item1 - s2.Item1), Math.Abs(s1.Item2 - s2.Item2))
	}
	
	// calculates the second part of the key of a grid cell
	// s: tuple for which key2 is to be calculated
	// return: key2 value of s
	def calcKey2(s : Tuple<real, real, integer, integer, integer, real, real>) : real {
		var key2 : real = Math.Min(s.Item3, s.Item4)
		return key2
	}
	
	// updates expandQueue by calling removeFromQueue method and adding a new tuple
	// u: tuple to be removed from expandQueue
	// newU: tuple to be added to expandQueue
	def updateQueue(u : Tuple<real, real, integer, integer, integer, real, real>, newU : Tuple<real, real, integer, integer, integer, real, real>) {
		removeFromQueue(u)
		expandQueue.Add(newU)
	}
	
	// updates routeList by creating a copy and adding s and all entries from old routeList unequal to s to it
	// s: new tuple to be added to routeList to replace old version of s
	def updateRouteList(s : Tuple<real, real, integer, integer, integer, real, real>) {
		var newRouteList = new List<Tuple<real, real, integer, integer, integer, real, real>>()
		each (var entry in routeList) {
			if ((entry.Item1 !== s.Item1) or (entry.Item2 !== s.Item2)) {
				newRouteList.Add(entry)
			}
			if ((entry.Item1 === s.Item1) and (entry.Item2 === s.Item2)) {
				newRouteList.Add(s)
			}
		}
		routeList = newRouteList
	}
	
	// removes a tuple from expandQueue
	// u: tuple to be removed from expandQueue
	def removeFromQueue(u : Tuple<real, real, integer, integer, integer, real, real>) {
		var newExpandQueue = new List<Tuple<real, real, integer, integer, integer, real, real>>()
		each (var s in expandQueue) {
			if ((s.Item1 !== u.Item1) or ((s.Item2 !== u.Item2))) {
				newExpandQueue.Add(s)
			}
		}
		expandQueue = newExpandQueue
	}
	
	// finds all grid cells neighboring s (and whether they have representative tuples in routeList or expandQueue)
	// s: tuple representing grid cell of which neighbors are to be found
	// return: list containing tuples representing neighbors of s
	def Neigh(s : Tuple<real, real, integer, integer, integer, real, real>) : List<Tuple<real, real, integer, integer, integer, real, real>> {
		var NeighList = new List<Tuple<real, real, integer, integer, integer, real, real>>()
		// TODO: durch inQueue-Aufrufe ersetzen
		var x : real
		var y : real
		for (x = s.Item1 - 1.0; x <= s.Item1 + 1.0; x++) {
			for (y = s.Item2 - 1.0; y <= s.Item2 + 1.0; y++) {
				if ((x !== s.Item1) or (y !== s.Item2)) {
					var found : bool = false
					each (r in routeList) {
						if ((r.Item1 === x) and (r.Item2 === y)) {
							NeighList.Add(r)
							found = true
						}
					}
					each (e in expandQueue) {
						if ((e.Item1 === x) and (e.Item2 === y)) {
							NeighList.Add(e)
							found = true
						}
					}
					if (not found) {
						var neigh = #(x, y, g, rhs, 0, 1000.0, 1000.0)
						var costNeigh = cost(neigh, s)
						if (costNeigh !== 1000) {
							var newNeigh = #(x, y, g, rhs, costNeigh, 1000.0, 1000.0)
							NeighList.Add(newNeigh)
						}
					}
				}
			}
		}
		return NeighList
	}
	
	// calculates the rhs value of tuple based on another tuple
	// s: tuple representing grid cell neighboring u
	// u: tuple representing grid cell currently being examined
	// return: updated rhs value
	def rhs(s : Tuple<real, real, integer, integer, integer, real, real>, u : Tuple<real, real, integer, integer, integer, real, real>) : integer {
		if ((s.Item1 === sStart.Item1) and (s.Item2 === sStart.Item2)) {
			return 0
		} else {
			var newRHS : integer = Math.Min(s.Item4, (cost(u, s) + u.Item3))
			return newRHS
		}
	}
	
	// updates tuple u by adding it to or removing it from expandQueue or changing its information
	// u: tuple to be updated
	// km: key modifier value
	// TODO: km aus args entfernen?
	def updateVertex(u : Tuple<real, real, integer, integer, integer, real, real>, km : real) {
		var isInQueue : bool = inQueue(u)
		var newKey1 = calcKey1(u, km)
		var newKey2 = calcKey2(u)
		if ((u.Item3 !== u.Item4) and isInQueue) {
			var uNew = #(u.Item1, u.Item2, u.Item3, u.Item4, u.Item5, newKey1, newKey2)
			updateQueue(u, uNew)
		} else if ((u.Item3 !== u.Item4) and (not isInQueue)) {
			var uNew = #(u.Item1, u.Item2, u.Item3, u.Item4, u.Item5, newKey1, newKey2)
			expandQueue.Add(uNew)
		} else if ((u.Item3 === u.Item4) and (isInQueue)) {
			routeList.Add(u)
			removeFromQueue(u)
		}
	}
	
	// checks if a tuple is in expandQueue
	// u: tuple to be checked
	// return: boolean
	def inQueue(u : Tuple<real, real, integer, integer, integer, real, real>) : bool {
		each (element in expandQueue) {
			if ((element.Item1 === u.Item1) and (element.Item2 === u.Item2)) {
				return true
			}
		}
		return false
	}
	
	// checks if a tuple is in routeList
	// u: tuple to be checked
	// return: boolean
	def inRouteList(u : Tuple<real, real, integer, integer, integer, real, real>) : bool {
		each (element in routeList) {
			if ((element.Item1 === u.Item1) and (element.Item2 === u.Item2)) {
				return true
			}
		}
		return false
	}
	
	// computes cost of moving from s to u and checks numeric value of s on grid layer
	// s: tuple representing the first grid cell to be used in cost calculation
	// u: tuple representing the second grid cell to be used in cost calculation
	// return: cost value on s
	def cost(s : Tuple<real, real, integer, integer, integer, real, real>, u : Tuple<real, real, integer, integer, integer, real, real>) : integer {
		var dist = heur(s, u)
		if (dist === 1.0) {
			if (battleground.GetIntegerValue(s.Item1, s.Item2) === 1) {
				return 1000
			} else if ((battleground.GetIntegerValue(s.Item1, s.Item2) === 2) or (battleground.GetIntegerValue(s.Item1, s.Item2) === 3)) {
				return 100
			} else {
				return 1
//				var cellCost = battleground.GetIntegerValue(s.Item1, s.Item2)
//				var guestList = explore Guest where [x => return ((x.X() !== xcor) and (x.Y() !== ycor))]
//				var guestCost : integer
//				each (guest in guestList) {
//					 var closeness : real = Math.Max(Math.Abs(guest.X() - s.Item1), Math.Abs(guest.Y() - s.Item2))
//					 if (closeness < 1.0) {
//					 	guestCost = guestCost + perimeterCost
//					 }
//					 if (closeness <= minSafetyDist) {
//					 	guestCost = guestCost + perimeterCost
//					 }
//				}
//				var result : integer = cellCost + guestCost
//				return result
			}
		} else if (dist < 1.0) {
			return 0
		} else {
			println("s and u are not neighbors!")
		}
		return 1
	}
	
	// obtains minimum rhs-value of all neighbors of s
	// s: tuple representing grid cell whose neighbors minimum rhs value is to be determined
	// neighListTemp: list of tuples representing grid cells that neighbor s
	// return: smallest rhs values among neighbors of s
	def getMinRHS(s : Tuple<real, real, integer, integer, integer, real, real>, neighListTemp: List<Tuple<real, real, integer, integer, integer, real, real>>) : integer {
		var minRHS = neighListTemp.Get(0).Item3 + cost(neighListTemp.Get(0), s)
		each (var neigh in neighListTemp) {
			var compRHS : integer = neigh.Item3 + cost(neigh, s)
			if (compRHS < minRHS) {
				minRHS = compRHS
			}
		}
		return minRHS
	}
	
	// prints a list of tuples
	// list: list of tuples to be printed
	def printQueue(list : List<Tuple<real, real, integer, integer, integer, real, real>>) {
		each (element in list) {
			println(element)
		}
	}

	// moves agent, if possible, one grid cell in the direction specified by the input parameter <direction>
	// TODO: implement a pathfinding algorithm (D*-algorithm?)
	def moveMe(x : real, y : real) {
		// moving away from a hill or ditch
		switch (battleground.GetIntegerValue(xcor, ycor)) {
			// hill
			case 2 : {
				var hill = nearest Hill
				hill.Free
				visibilityRange = visibilityRange - 3
				visualRange = visualRange - 3
			}
			// ditch
			case 3 : {
				var ditch = nearest Ditch
				ditch.Free
				visibilityRange = visibilityRange + 3
				visualRange = visualRange + 3
			}
			default : { }
		}
		// moving onto/into a hill or ditch		
		switch (battleground.GetIntegerValue(x, y)) {
			// hill
			case 2 : {
				var hill = explore Hill where [h => return (h.GetX === x) and (h.GetY === y)]
				hill[0].Occupy
				visibilityRange = visibilityRange + 3
				visualRange = visualRange + 3
			}
			// ditch
			case 3 : {
				var ditch = explore Ditch where [d => return (d.GetX === x) and (d.GetY === y)]
				ditch[0].Occupy
				visibilityRange = visibilityRange - 3
				visualRange = visualRange - 3
			}
		}
		move me to #(x, y)
		switch (currStance) {
			case "standing" : {	movementDelay = 0 }
			case "kneeling" : { movementDelay = 2 }
			case "lying" : { movementDelay = 3 }
		}
		hasMoved = true
	}

// **************************************************************************************** 
// ********************************* STANCE AND TAGGING ***********************************
// ****************************************************************************************

	// USER METHOD: changes currStance to <newStance>
	def changeStance(newStance : string) {
		if (actionPoints < 2) {	return }
		if (newStance === currStance) {	return }
		switch (currStance) {
			case "standing": {
				switch (newStance) {
					case "kneeling" : {
						visualRange = visualRange - 2
						visibilityRange = visibilityRange - 2
						movementDelay = 2
					}
					case "lying" : {
						visualRange = visualRange - 5
						visibilityRange = visibilityRange - 5
						movementDelay = 3
					}
				}
			}
			case "kneeling" : {
				switch (newStance) {
					case "standing" : {
						visualRange = visualRange + 2
						visibilityRange = visibilityRange + 2
						movementDelay = 0
					}
					case "lying" : {
						visualRange = visualRange - 3
						visibilityRange = visibilityRange - 3
						movementDelay = 3
					}
				}
			}
			case "lying" : {
				switch (newStance) {
					case "standing" : {
						visualRange = visualRange + 5
						visibilityRange = visibilityRange + 2
						movementDelay = 0
					}
					case "kneeling" : {
						visualRange = visualRange + 3
						visibilityRange = visibilityRange + 3
						movementDelay = 2
					}
				}
			}
		}
		currStance = newStance
		actionPoints = actionPoints - 2
	}

	// USER METHOD: tags a red enemy
	def tag(red : Red) {
		if (magazineCount < 1) { reload() }
		if (actionPoints < 5) { return }
		var tagReturn : bool = false
		var enemyStanceVal : integer = 2
		if (battleground.GetIntegerValue(red.GetX, red.GetY) === 2) { enemyStanceVal = 2 }
		else if (battleground.GetIntegerValue(red.GetX, red.GetY) === 3) { enemyStanceVal = 0 }
		else {
			switch (red.GetStance) {
				case "kneeling" : {	enemyStanceVal = 1 }
				case "lying" : { enemyStanceVal = 0	}
			}
		}
		switch (currStance) {
			case "standing" : {
				if (random(10) + 1 + enemyStanceVal > 8) {
					red.Tagged
					tagReturn = true
				}
			}
			case "kneeling" : {
				if (random(10) + 1 + enemyStanceVal > 6) {
					red.Tagged
					tagReturn = true
				}
			}
			case "lying" : {
				if (random(10) + 1 + enemyStanceVal > 4) {
					red.Tagged
					tagReturn = true
				}
			}
		}
		if (tagReturn) {
			tagged = true
			taggedCounter = 2
			points = points + 10
			if (red.GetEnergy <= 0) { points = points + 10 }
			println "A red agent is hit"
		} else { println "A red agent is missed" }
		magazineCount--
		actionPoints = actionPoints - 5
	}

	// USER METHOD: tags a blue enemy
	def tag(blue : Blue) {
		if (magazineCount < 1) { reload() }
		if (actionPoints < 5) { return }
		var tagReturn : bool = false
		var enemyStanceVal : integer = 0
		switch(blue.GetStance) {
			case "kneeling" : {	enemyStanceVal = 1 }
			case "lying" : { enemyStanceVal = 2	}
		}
		switch (currStance) {
			case "standing" : {
				if (random(10) + 1 + enemyStanceVal > 2) {
					blue.Tagged
					tagReturn = true
				}
			}
			case "kneeling" : {
				if (random(10) + 1 + enemyStanceVal > 4) {
					blue.Tagged
					tagReturn = true
				}
			}
			case "lying" : {
				if (random(10) + 1 + enemyStanceVal > 6) {
					blue.Tagged
					tagReturn = true
				}
			}
		}
		if (tagReturn) {
			tagged = true
			taggedCounter = 2
			points = points + 10
			if (blue.GetEnergy <= 0) { points = points + 10 }
			println "A blue agent is hit"
		} else { println "A blue agent is missed" }
		magazineCount--
		actionPoints = actionPoints - 5
	}

	// USER METHOD: tags a yellow enemy
	def tag(yellow : Yellow) {
		if (magazineCount < 1) { reload() }
		if (actionPoints < 5) { return }
		var tagReturn : bool = false
		var enemyStanceVal : integer = 0
		switch (yellow.GetStance) {
			case "kneeling" : {	enemyStanceVal = 1 }
			case "lying" : { enemyStanceVal = 2 }
		}
		switch (currStance) {
			case "standing" : {
				if (random(10) + 1 + enemyStanceVal > 2) {
					yellow.Tagged
					tagReturn = true
				}
			}
			case "kneeling" : {
				if (random(10) + 1 + enemyStanceVal > 4){
					yellow.Tagged
					tagReturn = true
				}
			}
			case "lying" : {
				if (random(10) + 1 + enemyStanceVal > 6) {
					yellow.Tagged
					tagReturn = true
				}
			}
		}
		if (tagReturn) {
			tagged = true
			taggedCounter = 2
			points = points + 10
			if (yellow.GetEnergy <= 0) { points = points + 10 }
			println "A yellow agent is hit"
		} else { println "A yellow agent is missed" }
		magazineCount--
		actionPoints = actionPoints - 5
	}
	
	// USER METHOD: checks if an enemy is located at (x, y) and, if so, attempts to tag that enemy
	def tag(x : real, y : real) {
		if (magazineCount < 1) { reload() }
		if (actionPoints < 5) { return }
		var potentialRed = explore Red where [r => return (r.GetX === x) and (r.GetY === y) and hasBeeline(xcor, ycor, r.GetX, r.GetY)]
		var potentialBlue = explore Blue where [b => return (b.GetX === x) and (b.GetY === y) and hasBeeline(xcor, ycor, b.GetX, b.GetY)]
		var potentialYellow = explore Yellow where [ye => return (ye.GetX === x) and (ye.GetY === y) and hasBeeline(xcor, ycor, ye.GetX, ye.GetY)]
		
		if (length(potentialRed) > 0) { println("green found red") }
		
		if (length(potentialRed) > 0) { tag(potentialRed[0]) }
		else if (length(potentialBlue) > 0) { tag(potentialBlue[0]) }
		else if (length(potentialYellow) > 0) { tag(potentialYellow[0]) }
		else {
			magazineCount--
			actionPoints = actionPoints - 5
		}
	}
	
	// refills magazineCount
	def reload() {
		if (actionPoints < 3) {	return }
		actionPoints = actionPoints - 3
		magazineCount = 5
		println("Green reloaded")
	}

// **************************************************************************************** 
// ***************************** POINTS AND PASSIVES BEGIN ********************************
// ****************************************************************************************

	// refills actionPoints and movementPoints
	// TODO: consider designing different solution for refilling points (to avoid having to touch tick methods)
	def refillPoints() {
		actionPoints = 10
		if (movementDelay > 0) { movementDelay-- }
		if (taggedCounter > 0) { taggedCounter-- }
		if (wasTaggedCounter > 0) { wasTaggedCounter-- }
		hasMoved = false
	}
	
	passive Tagged() {
		energy = energy - 20
		wasTagged = true
		wasTaggedCounter = 2
		if (energy <= 0) {
			energy = 100
			if (battleground.GetIntegerValue(xcor, ycor) === 2) {
				var hill = nearest Hill
				hill.Free
			} else if (battleground.GetIntegerValue(xcor, ycor) === 3) {
				var ditch = nearest Ditch
				ditch.Free
			}
			pos at #(xSpawn, ySpawn)
			stage = 0
		}
	}
	
	// returns current visibility range
	passive GetVisibility() => return visibilityRange
	
	// returns current stance
	passive GetStance() => return currStance
	
	// returns energy value
	passive GetEnergy() => return energy
	
	// returns current x-coordinate
	passive GetX() => return xcor
	
	// returns current y-coordinate
	passive GetY() => return ycor
	
}

// Team red
agent Red on Battleground {
//	*********************** general attributes ***********************
	observe var xSpawn : real = 1.0
	observe var ySpawn : real = 50.0
	observe var color : string = "red"
	observe var energy : integer = 100
	observe var actionPoints : integer = 10
	// TODO: define counter to decide when player can reenter game
	observe var stage : integer = 0
	observe var points : integer = 0
//	*********************** movement attributes ***********************
	// possible values: standing, kneeling, lying
	observe var currStance : string = "standing"
	observe var movementDelay : integer = 0
	observe var hasMoved : bool = false
//	*********************** exploration attributes ***********************
	observe var visualRange : real = 10
	observe var visibilityRange : real = 10
	var barriers = new List<Tuple<real, real>>
	var hills = new List<Tuple<real, real>>
	var ditches = new List<Tuple<real, real>>
//	*********************** tagging attributes ***********************
	observe var magazineCount : integer = 5
	// TODO: define way to reset wasTagged and tagged
	observe var wasTagged : bool = false
	observe var wasTaggedCounter : integer = 0
	observe var tagged : bool = false
	observe var taggedCounter : integer = 0
//	*********************** pathfinding attributes ***********************
	var g : integer = 1000
	var rhs : integer = 1000
	var km : real = 0.0
	// tuple values: (<x>, <y>, <g>, <rhs>, <cost> <key1>, <key2>)
	var sStart : Tuple<real, real, integer, integer, integer, real, real>
	var sGoal : Tuple<real, real, integer, integer, integer, real, real>
	var sLast : Tuple<real, real, integer, integer, integer, real, real>
	var routeList = new List<Tuple<real, real, integer, integer, integer, real, real>>()
	var expandQueue = new List<Tuple<real, real, integer, integer, integer, real, real>>()
	var pathCalculated : bool = false
	
	initialize {
		pos at #(xSpawn, ySpawn)
	}
	
	tick {
		if (stage === 0) {
			goTo(26.0, 26.0)
			if ((xcor === 26.0) and (ycor === 26.0)) {
				stage = 1
				exploreDitches()
				if (ditches.Size() > 0) {
					goTo(ditches.Get(0).Item1, ditches.Get(0).Item2)
				}
			}
		}
		if (stage === 1) {
			goTo(ditches.Get(0).Item1, ditches.Get(0).Item2)
			if ((xcor === ditches.Get(0).Item1) and (ycor === ditches.Get(0).Item2)) {
				stage = 2
			}
		}
		if (stage === 2) {
			var enemies = exploreEnemies()
			if (length(enemies.Item1) > 0) {
				var red = enemies.Item1
				var r = red[0]
				tag(r)
			}
		}
		refillPoints()
	}
	
// **************************************************************************************** 
// *************************** EXPLORATION AND VISION BEGIN *******************************
// ****************************************************************************************
	
	def exploreEnv(o : string) {
		if (actionPoints < 1) { return }
		switch (o) {
			case "barriers" : { exploreBarriers() }
			case "hills" : { exploreHills() }
			case "ditches" : { exploreDitches() }
		}
		actionPoints = actionPoints - 1
	}
	
	// generates a list of coordinates within visualRange that contain a wall
	def exploreBarriers() {
		var currBarriers = explore Barrier where [b => return ((distance b) <= visualRange and hasBeeline(xcor, ycor, b.GetX, b.GetY))]
		each (b in currBarriers) {
			var isContained : bool = false
			each (e in barriers) {
				if ((e.Item1 === b.GetX) and (e.Item2 === b.GetY)) {
					isContained = true
				}
			}			
			if (not isContained) {
				barriers.Add(#(b.GetX, b.GetY))
			}
		}
	}
	
	def exploreHills() {
		var currHills = explore Hill where [h => return ((distance h) <= visualRange and hasBeeline(xcor, ycor, h.GetX, h.GetY))]
		println length(currHills)
		each (h in currHills) {
			var isContained : bool = false
			each (e in hills) {
				if ((e.Item1 === h.GetX) and (e.Item2 === h.GetY)) {
					isContained = true
				}
			}
			if (not isContained) {
				hills.Add(#(h.GetX, h.GetY))
			}
		}
	}
	
	def exploreDitches() {
		var currDitches = explore Ditch where [d => return ((distance d) <= visualRange and hasBeeline(xcor, ycor, d.GetX, d.GetY))]
		each (d in currDitches) {
			var isContained : bool = false
			each (e in ditches) {
				if ((e.Item1 === d.GetX) and (e.Item2 === d.GetY)) {
					isContained = true
				}
			}
			if (not isContained) {
				ditches.Add(#(d.GetX, d.GetY))
			}
		}
	}
	
	// generates lists of coordinates of all enemies who can be seen
	// three conditions for being able to see an enemy:
		// 1) enemy coordinates are within visualRange
		// 2) enemy visibility makes enemy visible from my location
		// 3) there are no walls blocking linear vision between enemy and me
	def exploreEnemies() : Tuple<Green[], Blue[], Yellow[]> {
		var enemies = #(explore Green where [x => return (actionPoints > 0) and (((distance x) <= visualRange) or (battleground.GetIntegerValue(xcor, ycor) === 3)) and (((distance x) <= x.GetVisibility) or (battleground.GetIntegerValue(xcor, ycor) === 2)) and hasBeeline(xcor, ycor, x.GetX, x.GetY)],
						explore Blue where [x => return (actionPoints > 0) and (((distance x) <= visualRange) or (battleground.GetIntegerValue(xcor, ycor) === 3)) and (((distance x) <= x.GetVisibility) or (battleground.GetIntegerValue(xcor, ycor) === 2)) and hasBeeline(xcor, ycor, x.GetX, x.GetY)],
						explore Yellow where [x => return (actionPoints > 0) and (((distance x) <= visualRange) or (battleground.GetIntegerValue(xcor, ycor) === 3)) and (((distance x) <= x.GetVisibility) or (battleground.GetIntegerValue(xcor, ycor) === 2)) and hasBeeline(xcor, ycor, x.GetX, x.GetY)]
						)
		if (actionPoints > 0) {
			actionPoints = actionPoints - 1
		}
		return enemies
	}
	
	// implementation of Bresenham's Line Algorithm for obtaining a list of grid cells covered by a straight line between two points on the grid
	// http://tech-algorithm.com/articles/drawing-line-using-bresenham-algorithm/
	def hasBeeline(x1 : real, y1 : real, x2 : real, y2 : real) : bool {
	    var hasBeeline : bool = true
	    var x : integer = x1 as integer
	    var y : integer = y1 as integer
	    var newX2 : integer = x2 as integer
	    var newY2 : integer = y2 as integer
	    var w : integer = newX2 - x
	    var h : integer = newY2 - y
	    var dx1 : integer = 0
	    var dy1 : integer = 0
	    var dx2 : integer = 0
	    var dy2 : integer = 0
	    if (w < 0) {
	    	dx1 = -1
		} else if (w > 0) {
			dx1 = 1
		}
	    if (h < 0) {
	    	dy1 = -1
		} else if (h > 0) {
			dy1 = 1
		}
	    if (w < 0) {
	    	dx2 = -1
		} else if (w > 0) {
			dx2 = 1
		}
	    var longest : integer = Math.Abs(w)
	    var shortest : integer = Math.Abs(h)
	    if (not(longest > shortest)) {
	        longest = Math.Abs(h)
	        shortest = Math.Abs(w)
	        if (h < 0) {
	        	dy2 = -1
	    	} else if (h > 0) {
	    		dy2 = 1
	    	}
	        dx2 = 0          
	    }
	    var numerator : integer = longest / 2
	    for (var i=0; i < longest; i++) {
	        if (battleground.GetIntegerValue(x as real, y as real) === 1) {
				hasBeeline = false
				return hasBeeline
			}
	        numerator = numerator + shortest
	        if (not (numerator < longest)) {
	            numerator = numerator - longest
	            x = x + dx1
	            y = y + dy1
	        } else {
	            x = x + dx2
	            y = y + dy2
	        }
	    }
	    return hasBeeline
	}

// **************************************************************************************** 
// **************************** EXPLORATION AND VISION END ********************************
// ****************************************************************************************
	
// **************************************************************************************** 
// *********************************** MOVEMENT BEGIN *************************************
// ****************************************************************************************
	
	// TODO: clean up movement (remove unnecessary logic, code, methods)
	// implementation of modified D* Lite Algorithm for Agent pathfinding, movement, and path readjustment in case of unforeseen obstacles
	// xGoal: x-coordinate of grid cell Guest wants to move to
	// yGoal: y-coordinate of grid cell Guest wants to move to
	// return: boolean states if step was successfully taken
	def goTo(xGoal : real, yGoal : real) : bool {
		if (battleground.GetIntegerValue(xGoal, yGoal) === 1) {
			hasMoved = true
			return false
		}
		if ((movementDelay > 0) or hasMoved or ((xGoal === xcor) and (yGoal === ycor))) {
			return false
		}
		// TODO: ist pathCalculated noch nötig?
		if (not pathCalculated) {
			initPathfinding(xGoal, yGoal)
		}
		sStart = findNextCell()
		var neighsInRouteList = findNeighsInRouteList()
		var neighsWithChangedCost = scanCostChanges(neighsInRouteList)
		if (neighsWithChangedCost.Size() !== 0) {
			// calculation of completely new path
			var newExpandQueue = new List<Tuple<real, real, integer, integer, integer, real, real>>
			expandQueue = newExpandQueue
			var newRouteList = new List<Tuple<real, real, integer, integer, integer, real, real>>
			routeList = newRouteList
			var keyInit = Math.Max(Math.Abs(xcor - xGoal), Math.Abs(ycor - yGoal))
			sGoal = #(xGoal, yGoal, g, 0, battleground.GetIntegerValue(xGoal, yGoal), keyInit, 0.0)
			expandQueue.Add(sGoal)
			km = 0.0
			sStart = #(xcor, ycor, g, rhs, battleground.GetIntegerValue(xcor, ycor), 1000.0, 1000.0)
			sLast = sStart
			computeShortestPath(sStart, km)
			sStart = findNextCell()
		}
		if (battleground.GetIntegerValue(sStart.Item1, sStart.Item2) === 2) {
			var hill = explore Hill where [h => return (h.GetX === sStart.Item1) and (h.GetY === sStart.Item2)]
			if (not hill[0].IsFree) {
				pathCalculated = false
				return false
			}
		} else if (battleground.GetIntegerValue(sStart.Item1, sStart.Item2) === 3) {
			var ditch = nearest Ditch where [d => return (d.GetX === sStart.Item1) and (d.GetY === sStart.Item2)]
			if (not ditch.IsFree) {
				pathCalculated = false
				return false
			}
		}
		moveMe(sStart.Item1, sStart.Item2)
		if ((xcor === sGoal.Item1) and (ycor === sGoal.Item2)) {
			pathCalculated = false
		}
		return true
	}
	
	// computes initial route from (xcor, ycor) to (<xGoal>, <yGoal>)
	// xGoal: x-coordinate of grid cell Guest wants to move to
	// yGoal: y-coordinate of grid cell Guest wants to move to
	def initPathfinding(xGoal : real, yGoal : real) {
		var costSStart = battleground.GetIntegerValue(xcor, ycor)
		sStart = #(xcor, ycor, g, rhs, costSStart, 1000.0, 1000.0)
		sLast = sStart
		var keyInit = Math.Max(Math.Abs(xcor - xGoal), Math.Abs(ycor - yGoal))
		var costSGoal = battleground.GetIntegerValue(xGoal, yGoal)
		sGoal = #(xGoal, yGoal, g, 0, costSGoal, keyInit, 0.0)
		expandQueue = new List<Tuple<real, real, integer, integer, integer, real, real>>
		routeList = new List<Tuple<real, real, integer, integer, integer, real, real>>
		expandQueue.Add(sGoal)
		computeShortestPath(sStart, km)
		pathCalculated = true
	}
	
	// computes shortest path from current position to goal
	// sStart: tuple representing grid cell from which Guest starts moving towards goal
	// km: key modifier value
	def computeShortestPath(sStart : Tuple<real, real, integer, integer, integer, real, real>, km : real) {
		var u : Tuple<real, real, integer, integer, integer, real, real> = getTopKey()
		while ((u.Item6 !== 0.0) and ((u.Item6 < calcKey1(sStart, km)) or (sStart.Item4 > sStart.Item3))) {
			var kOld1 = u.Item6
			var kNew1 = calcKey1(u, km)
			var kNew2 = calcKey2(u)
			if (kOld1 < kNew1) {
				var v = #(u.Item1, u.Item2, u.Item3, u.Item4, u.Item5, kNew1, kNew2)
				updateQueue(u, v)
			} else if (u.Item3 > u.Item4) {
				var uNew = #(u.Item1, u.Item2, u.Item4, u.Item4, u.Item5, u.Item6, u.Item7)
				routeList.Add(uNew)
				var NeighList = Neigh(uNew)
				removeFromQueue(u)
				each (var s in NeighList) {
					if ((s.Item1 !== sGoal.Item1) or (s.Item2 !== sGoal.Item2)) {
						var newRHS = rhs(s, uNew)
						var sNew = #(s.Item1, s.Item2, s.Item3, newRHS, s.Item5, s.Item6, s.Item7)
						updateVertex(sNew, km)
					}
				}
			} else {
				var gOld = u.Item3
				var uNew = #(u.Item1, u.Item2, g, u.Item4, u.Item5, u.Item6, u.Item7)
				updateQueue(u, uNew)
				var neighList = Neigh(uNew)
				neighList.Add(uNew)
				each (var s in neighList) {
					var updated : bool = false
					if (s.Item4 === (u.Item5 + gOld)) {
						if ((s.Item1 !== sGoal.Item1) or (s.Item2 !== sGoal.Item2)) {
							var neighListTemp = Neigh(s)
							var newRHS = getMinRHS(s, neighListTemp)
							var newS = #(s.Item1, s.Item2, s.Item3, newRHS, s.Item5, s.Item6, s.Item7)
							updateVertex(newS, km)
							updated = true
						}
					}
					if (not updated) {
						updateVertex(s, km)
					}
				}
			}
			u = getTopKey()
		}
	}
	
	// determines which cell an Guest should move to next
	// return: tuple representing grid cell that Guest needs to move to
	def findNextCell() : Tuple<real, real, integer, integer, integer, real, real> {
		var nextCellCandidates = findNeighsInRouteList()
		var minNeigh = nextCellCandidates.Get(0)
		each (var neigh in nextCellCandidates) {
			if ((cost(neigh, sStart) + neigh.Item3) < (cost(minNeigh, sStart) + minNeigh.Item3)) {
				minNeigh = neigh
			} else if ((cost(neigh, sStart) + neigh.Item3) === (cost(minNeigh, sStart) + minNeigh.Item3)) {
				if ((xcor === neigh.Item1) or (ycor === neigh.Item2)) {
					minNeigh = neigh
				}
			}
		}
		return minNeigh
	}
	
	// creates a list of tuples representing grid cells that are neighbors of sStart and that are in routeList
	// return: list of tuples
	def findNeighsInRouteList() : List<Tuple<real, real, integer, integer, integer, real, real>> {
		var nextCellCandidates = new List<Tuple<real, real, integer, integer, integer, real, real>>()
		each (var s in routeList) {
			if (heur(sStart, s) === 1.0) {
				nextCellCandidates.Add(s)
			}
		}
		return nextCellCandidates
	}
  
	// determines for all elements of List if their cost is not equal to 1.
	// List: neighbors of sStart
	// return: list with neighbors of sStart that are in routeList and whose cost is not equal to 1
	def scanCostChanges(neighsinRouteList : List<Tuple<real, real, integer, integer, integer, real, real>>) : List<Tuple<real, real, integer, integer, integer, real, real>> {
		var currCostNeigh : integer
		var neighsWithChangedCost = new List<Tuple<real, real, integer, integer, integer, real, real>>()
		each(currNeigh in neighsinRouteList){
			currCostNeigh = cost(currNeigh, sStart)
			if (currCostNeigh !== currNeigh.Item5) {
				neighsWithChangedCost.Add(currNeigh)
			}
		}
		return neighsWithChangedCost
	}
	
	// obtains the next cell that should be examined during pathfinding
	// return: tuple with most favorable key1 and key2
	def getTopKey() : Tuple<real, real, integer, integer, integer, real, real> {
    	var minKey1 : real = expandQueue.Get(0).Item6
    	var minKey2 : real = expandQueue.Get(0).Item7
    	each (currElem in expandQueue) {
      		if (currElem.Item6 < minKey1) {
				minKey1 = currElem.Item6
				minKey2 = currElem.Item7
			} else if ((currElem.Item6 === minKey1) and (currElem.Item7 < minKey2)) {
				minKey2 = currElem.Item7
			}
		}
		var minKeyTuple : Tuple<real, real, integer, integer, integer, real, real>
		for (var i = 0; i < expandQueue.Size(); i++) {
			if ((expandQueue.Get(i).Item6 === minKey1) and (expandQueue.Get(i).Item7 === minKey2)) {
				minKeyTuple = expandQueue.Get(i)
				i = expandQueue.Size()
			}
		}
		return minKeyTuple
	}
	
	// calculates the first part of the key of a grid cell (using heuristic)
	// s: tuple for which key1 is to be calculated
	// km: key modifier value
	// return: key1 value of s
	def calcKey1(s : Tuple<real, real, integer, integer, integer, real, real>, km : real) : real {
		return Math.Min(s.Item3, s.Item4) + heur(sStart, s) + km
	}
	
	// heuristic: takes the larger value of the x-range and y-range between two grid cells
	// s1: tuple representing the first grid cell to be used in heuristic calculation
	// s2: tuple representing the second grid cell to be used in heuristic calculation
	// return: result of heuristic calculation
	def heur(s1 : Tuple<real, real, integer, integer, integer, real, real>, s2 : Tuple<real, real, integer, integer, integer, real, real>) : real {
		return Math.Max(Math.Abs(s1.Item1 - s2.Item1), Math.Abs(s1.Item2 - s2.Item2))
	}
	
	// calculates the second part of the key of a grid cell
	// s: tuple for which key2 is to be calculated
	// return: key2 value of s
	def calcKey2(s : Tuple<real, real, integer, integer, integer, real, real>) : real {
		var key2 : real = Math.Min(s.Item3, s.Item4)
		return key2
	}
	
	// updates expandQueue by calling removeFromQueue method and adding a new tuple
	// u: tuple to be removed from expandQueue
	// newU: tuple to be added to expandQueue
	def updateQueue(u : Tuple<real, real, integer, integer, integer, real, real>, newU : Tuple<real, real, integer, integer, integer, real, real>) {
		removeFromQueue(u)
		expandQueue.Add(newU)
	}
	
	// updates routeList by creating a copy and adding s and all entries from old routeList unequal to s to it
	// s: new tuple to be added to routeList to replace old version of s
	def updateRouteList(s : Tuple<real, real, integer, integer, integer, real, real>) {
		var newRouteList = new List<Tuple<real, real, integer, integer, integer, real, real>>()
		each (var entry in routeList) {
			if ((entry.Item1 !== s.Item1) or (entry.Item2 !== s.Item2)) {
				newRouteList.Add(entry)
			}
			if ((entry.Item1 === s.Item1) and (entry.Item2 === s.Item2)) {
				newRouteList.Add(s)
			}
		}
		routeList = newRouteList
	}
	
	// removes a tuple from expandQueue
	// u: tuple to be removed from expandQueue
	def removeFromQueue(u : Tuple<real, real, integer, integer, integer, real, real>) {
		var newExpandQueue = new List<Tuple<real, real, integer, integer, integer, real, real>>()
		each (var s in expandQueue) {
			if ((s.Item1 !== u.Item1) or ((s.Item2 !== u.Item2))) {
				newExpandQueue.Add(s)
			}
		}
		expandQueue = newExpandQueue
	}
	
	// finds all grid cells neighboring s (and whether they have representative tuples in routeList or expandQueue)
	// s: tuple representing grid cell of which neighbors are to be found
	// return: list containing tuples representing neighbors of s
	def Neigh(s : Tuple<real, real, integer, integer, integer, real, real>) : List<Tuple<real, real, integer, integer, integer, real, real>> {
		var NeighList = new List<Tuple<real, real, integer, integer, integer, real, real>>()
		// TODO: durch inQueue-Aufrufe ersetzen
		var x : real
		var y : real
		for (x = s.Item1 - 1.0; x <= s.Item1 + 1.0; x++) {
			for (y = s.Item2 - 1.0; y <= s.Item2 + 1.0; y++) {
				if ((x !== s.Item1) or (y !== s.Item2)) {
					var found : bool = false
					each (r in routeList) {
						if ((r.Item1 === x) and (r.Item2 === y)) {
							NeighList.Add(r)
							found = true
						}
					}
					each (e in expandQueue) {
						if ((e.Item1 === x) and (e.Item2 === y)) {
							NeighList.Add(e)
							found = true
						}
					}
					if (not found) {
						var neigh = #(x, y, g, rhs, 0, 1000.0, 1000.0)
						var costNeigh = cost(neigh, s)
						if (costNeigh !== 1000) {
							var newNeigh = #(x, y, g, rhs, costNeigh, 1000.0, 1000.0)
							NeighList.Add(newNeigh)
						}
					}
				}
			}
		}
		return NeighList
	}
	
	// calculates the rhs value of tuple based on another tuple
	// s: tuple representing grid cell neighboring u
	// u: tuple representing grid cell currently being examined
	// return: updated rhs value
	def rhs(s : Tuple<real, real, integer, integer, integer, real, real>, u : Tuple<real, real, integer, integer, integer, real, real>) : integer {
		if ((s.Item1 === sStart.Item1) and (s.Item2 === sStart.Item2)) {
			return 0
		} else {
			var newRHS : integer = Math.Min(s.Item4, (cost(u, s) + u.Item3))
			return newRHS
		}
	}
	
	// updates tuple u by adding it to or removing it from expandQueue or changing its information
	// u: tuple to be updated
	// km: key modifier value
	// TODO: km aus args entfernen?
	def updateVertex(u : Tuple<real, real, integer, integer, integer, real, real>, km : real) {
		var isInQueue : bool = inQueue(u)
		var newKey1 = calcKey1(u, km)
		var newKey2 = calcKey2(u)
		if ((u.Item3 !== u.Item4) and isInQueue) {
			var uNew = #(u.Item1, u.Item2, u.Item3, u.Item4, u.Item5, newKey1, newKey2)
			updateQueue(u, uNew)
		} else if ((u.Item3 !== u.Item4) and (not isInQueue)) {
			var uNew = #(u.Item1, u.Item2, u.Item3, u.Item4, u.Item5, newKey1, newKey2)
			expandQueue.Add(uNew)
		} else if ((u.Item3 === u.Item4) and (isInQueue)) {
			routeList.Add(u)
			removeFromQueue(u)
		}
	}
	
	// checks if a tuple is in expandQueue
	// u: tuple to be checked
	// return: boolean
	def inQueue(u : Tuple<real, real, integer, integer, integer, real, real>) : bool {
		each (element in expandQueue) {
			if ((element.Item1 === u.Item1) and (element.Item2 === u.Item2)) {
				return true
			}
		}
		return false
	}
	
	// checks if a tuple is in routeList
	// u: tuple to be checked
	// return: boolean
	def inRouteList(u : Tuple<real, real, integer, integer, integer, real, real>) : bool {
		each (element in routeList) {
			if ((element.Item1 === u.Item1) and (element.Item2 === u.Item2)) {
				return true
			}
		}
		return false
	}
	
	// computes cost of moving from s to u and checks numeric value of s on grid layer
	// s: tuple representing the first grid cell to be used in cost calculation
	// u: tuple representing the second grid cell to be used in cost calculation
	// return: cost value on s
	def cost(s : Tuple<real, real, integer, integer, integer, real, real>, u : Tuple<real, real, integer, integer, integer, real, real>) : integer {
		var dist = heur(s, u)
		if (dist === 1.0) {
			if (battleground.GetIntegerValue(s.Item1, s.Item2) === 1) {
				return 1000
			} else if ((battleground.GetIntegerValue(s.Item1, s.Item2) === 2) or (battleground.GetIntegerValue(s.Item1, s.Item2) === 3)) {
				return 100
			} else {
				return 1
//				var cellCost = battleground.GetIntegerValue(s.Item1, s.Item2)
//				var guestList = explore Guest where [x => return ((x.X() !== xcor) and (x.Y() !== ycor))]
//				var guestCost : integer
//				each (guest in guestList) {
//					 var closeness : real = Math.Max(Math.Abs(guest.X() - s.Item1), Math.Abs(guest.Y() - s.Item2))
//					 if (closeness < 1.0) {
//					 	guestCost = guestCost + perimeterCost
//					 }
//					 if (closeness <= minSafetyDist) {
//					 	guestCost = guestCost + perimeterCost
//					 }
//				}
//				var result : integer = cellCost + guestCost
//				return result
			}
		} else if (dist < 1.0) {
			return 0
		} else {
			println("s and u are not neighbors!")
		}
		return 1
	}
	
	// obtains minimum rhs-value of all neighbors of s
	// s: tuple representing grid cell whose neighbors minimum rhs value is to be determined
	// neighListTemp: list of tuples representing grid cells that neighbor s
	// return: smallest rhs values among neighbors of s
	def getMinRHS(s : Tuple<real, real, integer, integer, integer, real, real>, neighListTemp: List<Tuple<real, real, integer, integer, integer, real, real>>) : integer {
		var minRHS = neighListTemp.Get(0).Item3 + cost(neighListTemp.Get(0), s)
		each (var neigh in neighListTemp) {
			var compRHS : integer = neigh.Item3 + cost(neigh, s)
			if (compRHS < minRHS) {
				minRHS = compRHS
			}
		}
		return minRHS
	}
	
	// prints a list of tuples
	// list: list of tuples to be printed
	def printQueue(list : List<Tuple<real, real, integer, integer, integer, real, real>>) {
		each (element in list) {
			println(element)
		}
	}

	// moves agent, if possible, one grid cell in the direction specified by the input parameter <direction>
	// TODO: implement a pathfinding algorithm (D*-algorithm?)
	def moveMe(x : real, y : real) {
		// moving away from a hill or ditch
		switch (battleground.GetIntegerValue(xcor, ycor)) {
			// hill
			case 2 : {
				var hill = nearest Hill
				hill.Free
				visibilityRange = visibilityRange - 3
				visualRange = visualRange - 3
			}
			// ditch
			case 3 : {
				var ditch = nearest Ditch
				ditch.Free
				visibilityRange = visibilityRange + 3
				visualRange = visualRange + 3
			}
			default : { }
		}
		// moving onto/into a hill or ditch		
		switch (battleground.GetIntegerValue(x, y)) {
			// hill
			case 2 : {
				var hill = explore Hill where [h => return (h.GetX === x) and (h.GetY === y)]
				hill[0].Occupy
				visibilityRange = visibilityRange + 3
				visualRange = visualRange + 3
			}
			// ditch
			case 3 : {
				var ditch = explore Ditch where [d => return (d.GetX === x) and (d.GetY === y)]
				ditch[0].Occupy
				visibilityRange = visibilityRange - 3
				visualRange = visualRange - 3
			}
		}
		move me to #(x, y)
		switch (currStance) {
			case "standing" : {	movementDelay = 0 }
			case "kneeling" : { movementDelay = 2 }
			case "lying" : { movementDelay = 3 }
		}
		hasMoved = true
	}

// **************************************************************************************** 
// *********************************** MOVEMENT END ***************************************
// ****************************************************************************************

// **************************************************************************************** 
// ****************************** STANCE AND TAGGING BEGIN ********************************
// ****************************************************************************************

	// changes currStance to <newStance>
	def changeStance(newStance : string) {
		if (actionPoints < 2) {	return }
		if (newStance === currStance) {	return }
		switch (currStance) {
			case "standing": {
				switch (newStance) {
					case "kneeling" : {
						visualRange = visualRange - 2
						visibilityRange = visibilityRange - 2
						movementDelay = 2
					}
					case "lying" : {
						visualRange = visualRange - 5
						visibilityRange = visibilityRange - 5
						movementDelay = 3
					}
				}
			}
			case "kneeling" : {
				switch (newStance) {
					case "standing" : {
						visualRange = visualRange + 2
						visibilityRange = visibilityRange + 2
						movementDelay = 0
					}
					case "lying" : {
						visualRange = visualRange - 3
						visibilityRange = visibilityRange - 3
						movementDelay = 3
					}
				}
			}
			case "lying" : {
				switch (newStance) {
					case "standing" : {
						visualRange = visualRange + 5
						visibilityRange = visibilityRange + 2
						movementDelay = 0
					}
					case "kneeling" : {
						visualRange = visualRange + 3
						visibilityRange = visibilityRange + 3
						movementDelay = 2
					}
				}
			}
		}
		currStance = newStance
		actionPoints = actionPoints - 2
	}

	// tags an enemy whose coordinates are in enemyList
	// enemy_team string : "red" "blue" "yellow"
	//TODO: check if enemy is in this agent's view (not allies' view)
	def tag(green : Green) {
		if (magazineCount < 1) { reload() }
		if (actionPoints < 5) { return }
		//probability system based on stances of both agent
		var tagReturn : bool = false
		//more likely to get hit if enemy agent gets into a lower stance
		var enemyStanceVal : integer = 2
		if (battleground.GetIntegerValue(green.GetX, green.GetY) === 2) { enemyStanceVal = 2 }
		else if (battleground.GetIntegerValue(green.GetX, green.GetY) === 3) { enemyStanceVal = 0 }
		else {
			switch(green.GetStance) {
				case "kneeling" : {	enemyStanceVal = 1 }
				case "lying" : { enemyStanceVal = 0	}
			}
		}
		switch(currStance) {
			case "standing" : {
				if (random(10) + 1 + enemyStanceVal > 8) {
					green.Tagged
					tagReturn = true
				}
			}
			case "kneeling" : {
				if (random(10) + 1 + enemyStanceVal > 6) {
					green.Tagged
					tagReturn = true
				}
			}
			case "lying" : {
				if (random(10) + 1 + enemyStanceVal > 4) {
					green.Tagged
					tagReturn = true
				}
			}
		}
		if (tagReturn) {
			tagged = true
			taggedCounter = 2
			points = points + 10
			if (green.GetEnergy <= 0) { points = points + 10 }
			println "A green agent is hit"
		} else { println "A green agent is missed" }
		magazineCount--
		actionPoints = actionPoints - 5
	}

	// tags an enemy whose coordinates are in enemyList
	// enemy_team string : "red" "blue" "yellow"
	//TODO: check if enemy is in this agent's view (not allies' view)
	def tag(blue : Blue) {
		if (magazineCount < 1) {reload()}
		if (actionPoints < 5) {return}
		//probability system based on stances of both agent
		var tagReturn : bool = false
		
		//more likely to get hit if enemy agent gets into a lower stance
		var enemyStanceVal : integer = 0
		switch(blue.GetStance) {
			case "kneeling" : {	enemyStanceVal = 1
			}
			case "lying" : {
				enemyStanceVal = 2
			}
		}
		
		switch(currStance){
			case "standing" : {
				if (random(10) + 1 + enemyStanceVal > 2){
					blue.Tagged
					tagReturn = true
				}
			}
			case "kneeling" : {
				if (random(10) + 1 + enemyStanceVal > 4){
					blue.Tagged
					tagReturn = true
				}
			}
			case "lying" : {
				if (random(10) + 1 + enemyStanceVal > 6){
					blue.Tagged
					tagReturn = true
				}
			}
		}
		if (tagReturn){
			tagged = true
			taggedCounter = 2
			points = points + 10
			if (blue.GetEnergy <= 0) { points = points + 10 }
			println "A blue agent is hit"
		} else { println "A blue agent is missed" }
		magazineCount--
		actionPoints = actionPoints - 5
	}

	// tags an enemy whose coordinates are in enemyList
	// enemy_team string : "red" "blue" "yellow"
	//TODO: check if enemy is in this agent's view (not allies' view)
	def tag(yellow : Yellow) {
		if (magazineCount < 1) {reload()}
		if (actionPoints < 5) {return}
		//probability system based on stances of both agent
		var tagReturn : bool = false
		
		//more likely to get hit if enemy agent gets into a lower stance
		var enemyStanceVal : integer = 0
		switch(yellow.GetStance) {
			case "kneeling" : {	enemyStanceVal = 1
			}
			case "lying" : {
				enemyStanceVal = 2
			}
		}
		
		switch(currStance){
			case "standing" : {
				if (random(10) + 1 + enemyStanceVal > 2){
					yellow.Tagged
					tagReturn = true
				}
			}
			case "kneeling" : {
				if (random(10) + 1 + enemyStanceVal > 4){
					yellow.Tagged
					tagReturn = true
				}
			}
			case "lying" : {
				if (random(10) + 1 + enemyStanceVal > 6){
					yellow.Tagged
					tagReturn = true
				}
			}
		}
		if (tagReturn){
			tagged = true
			taggedCounter = 2
			points = points + 10
			if (yellow.GetEnergy <= 0) { points = points + 10 }
			println "A yellow agent is hit"
		} else { println "A yellow agent is missed" }
		magazineCount--
		actionPoints = actionPoints - 5
	}
	
	//alternate method choosing an enemy coordinate (more options)
	def tag(xCor : real, yCor : real) {
		if (magazineCount < 1) { reload() }
		if (actionPoints < 5) { return }
		
		var potentialGreen = explore Green where [x => return (x.GetX === xCor) and (x.GetY === yCor) and hasBeeline(xcor, ycor, x.GetX, x.GetY)]
		var potentialBlue = explore Blue where [x => return (x.GetX === xCor) and (x.GetY === yCor) and hasBeeline(xcor, ycor, x.GetX, x.GetY)]
		var potentialYellow = explore Yellow where [x => return (x.GetX === xCor) and (x.GetY === yCor) and hasBeeline(xcor, ycor, x.GetX, x.GetY)]
		
		if (length(potentialGreen) > 0) { tag(potentialGreen[0]) }
		else if (length(potentialBlue) > 0) { tag(potentialBlue[0]) }
		else if (length(potentialYellow) > 0) { tag(potentialYellow[0]) }
		else {
			magazineCount--
			actionPoints = actionPoints - 5
		}
	}
	
	// refills magazineCount
	def reload() {
		if (actionPoints < 3) {	return }
		actionPoints = actionPoints - 3
		magazineCount = 5
		println("Red reloaded")
	}


// **************************************************************************************** 
// ******************************* STANCE AND TAGGING END *********************************
// ****************************************************************************************

// **************************************************************************************** 
// ***************************** POINTS AND PASSIVES BEGIN ********************************
// ****************************************************************************************

	// refills actionPoints and movementPoints
	// TODO: consider designing different solution for refilling points (to avoid having to touch tick methods)
	def refillPoints() {
		actionPoints = 10
		if (movementDelay > 0) { movementDelay-- }
		if (taggedCounter > 0) { taggedCounter-- }
		if (wasTaggedCounter > 0) { wasTaggedCounter-- }
		hasMoved = false
	}
	
	passive Tagged() {
		energy = energy - 20
		wasTagged = true
		wasTaggedCounter = 2
		if (energy <= 0) {
			energy = 100
			pos at #(xSpawn, ySpawn)
			stage = 0
		}
	}
	
	// returns current visibility range
	passive GetVisibility() => return visibilityRange
	
	// returns current stance
	passive GetStance() => return currStance
	
	// returns energy value
	passive GetEnergy() => return energy
	
	// returns current x-coordinate
	passive GetX() => return xcor
	
	// returns current y-coordinate
	passive GetY() => return ycor
	
// **************************************************************************************** 
// ****************************** POINTS AND PASSIVES END *********************************
// ****************************************************************************************
	
}

// Team blue
agent Blue on Battleground {
	//	*********************** general attributes ***********************
	observe var xSpawn : real = 50.0
	observe var ySpawn : real = 50.0
	observe var color : string = "blue"
	observe var energy : integer = 100
	observe var actionPoints : integer = 10
	// TODO: define counter to decide when player can reenter game
	observe var inGame : bool = true
	observe var stage : integer = 0
//	*********************** movement attributes ***********************
	// possible values: standing, kneeling, lying
	observe var currStance : string = "standing"
	observe var movementDelay : integer = 0
	observe var hasMoved : bool = false
//	*********************** exploration attributes ***********************
	observe var visualRange : real = 10
	observe var visibilityRange : real = 10
	var enemies : Tuple<List<Green>, List<Red>, List<Yellow>>
	var barriers : Barrier[]
	var hills : Hill[]
	var ditches : Ditch[]
//	*********************** tagging attributes ***********************
	observe var magazineCount : integer = 5
	// TODO: define way to reset wasTagged and tagged
	observe var wasTagged : bool = false
	observe var wasTaggedCounter : integer = 0
	observe var tagged : bool = false
	observe var tagedCounter : integer = 0
//	*********************** pathfinding attributes ***********************
	var g : integer = 1000
	var rhs : integer = 1000
	var km : real = 0.0
	// tuple values: (<x>, <y>, <g>, <rhs>, <cost> <key1>, <key2>)
	var sStart : Tuple<real, real, integer, integer, integer, real, real>
	var sGoal : Tuple<real, real, integer, integer, integer, real, real>
	var sLast : Tuple<real, real, integer, integer, integer, real, real>
	var routeList = new List<Tuple<real, real, integer, integer, integer, real, real>>()
	var expandQueue = new List<Tuple<real, real, integer, integer, integer, real, real>>()
	var pathCalculated : bool = false
	
	initialize {
		
	}
	
	tick {
		
	}
	
	// **************************************************************************************** 
// ***************************** POINTS AND PASSIVES BEGIN ********************************
// ****************************************************************************************

	// refills actionPoints and movementPoints
	// TODO: consider designing different solution for refilling points (to avoid having to touch tick methods)
	def refillPoints() {
		actionPoints = 10
		if (movementDelay > 0) {
			movementDelay = movementDelay - 1		
		}
		enemies = #(new List<Green>, new List<Red>, new List<Yellow>)
		hasMoved = false
	}

	passive Tagged() {
		energy = energy - 20
		wasTagged = true
		wasTaggedCounter = 2
		if (energy <= 0) {
			energy = 100
			pos at #(xSpawn, ySpawn)
		}
	}
	
	// returns current visibility range
	passive GetVisibility() => return visibilityRange

	// returns current stance
	passive GetStance() => return currStance

	// returns energy value
	passive GetEnergy() => return energy
	
	// returns current x-coordinate
	passive GetX() => return xcor
	
	// returns current y-coordinate
	passive GetY() => return ycor
	
// **************************************************************************************** 
// ****************************** POINTS AND PASSIVES END *********************************
// ****************************************************************************************
	
}

// Team yellow
agent Yellow on Battleground {
	//	*********************** general attributes ***********************
	observe var xSpawn : real = 50.0
	observe var ySpawn : real = 1.0
	observe var color : string = "yellow"
	observe var energy : integer = 100
	observe var actionPoints : integer = 10
	// TODO: define counter to decide when player can reenter game
	observe var inGame : bool = true
	observe var stage : integer = 0
//	*********************** movement attributes ***********************
	// possible values: standing, kneeling, lying
	observe var currStance : string = "standing"
	observe var movementDelay : integer = 0
	observe var hasMoved : bool = false
//	*********************** exploration attributes ***********************
	observe var visualRange : real = 10
	observe var visibilityRange : real = 10
	var enemies : Tuple<List<Green>, List<Red>, List<Blue>>
	var barriers : Barrier[]
	var hills : Hill[]
	var ditches : Ditch[]
//	*********************** tagging attributes ***********************
	observe var magazineCount : integer = 5
	// TODO: define way to reset wasTagged and tagged
	observe var wasTagged : bool = false
	observe var wasTaggedCounter : integer = 0
	observe var tagged : bool = false
	observe var tagedCounter : integer = 0
//	*********************** pathfinding attributes ***********************
	var g : integer = 1000
	var rhs : integer = 1000
	var km : real = 0.0
	// tuple values: (<x>, <y>, <g>, <rhs>, <cost> <key1>, <key2>)
	var sStart : Tuple<real, real, integer, integer, integer, real, real>
	var sGoal : Tuple<real, real, integer, integer, integer, real, real>
	var sLast : Tuple<real, real, integer, integer, integer, real, real>
	var routeList = new List<Tuple<real, real, integer, integer, integer, real, real>>()
	var expandQueue = new List<Tuple<real, real, integer, integer, integer, real, real>>()
	var pathCalculated : bool = false
	
	initialize {
		
	}
	
	tick {
		
	}
	
// **************************************************************************************** 
// ***************************** POINTS AND PASSIVES BEGIN ********************************
// ****************************************************************************************

	// refills actionPoints and movementPoints
	// TODO: consider designing different solution for refilling points (to avoid having to touch tick methods)
	def refillPoints() {
		actionPoints = 10
		if (movementDelay > 0) {
			movementDelay = movementDelay - 1		
		}
		hasMoved = false
	}
	
	passive Tagged() {
		energy = energy - 20
		wasTagged = true
		wasTaggedCounter = 2
		if (energy <= 0) {
			energy = 100
			pos at #(xSpawn, ySpawn)
		}
	}
	
	// returns current visibility range
	passive GetVisibility() => return visibilityRange

	// returns current stance
	passive GetStance() => return currStance

	// returns energy value
	passive GetEnergy() => return energy
	
	// returns current x-coordinate
	passive GetX() => return xcor
	
	// returns current y-coordinate
	passive GetY() => return ycor
	
// **************************************************************************************** 
// ****************************** POINTS AND PASSIVES END *********************************
// ****************************************************************************************
	
}

// ************************************************************************************************
// **************************************** PASSIVE AGENTS ****************************************
// ************************************************************************************************

agent Spawner on Battleground {
	
	initialize {
		for(var x = 0; x < battleground.DimensionX; x++) {
			for(var y = 0; y < battleground.DimensionY; y++) {
				pos me at #(x, y)
				var value = battleground.GetIntegerValue(x, y)
				switch (value) {
					case 1 : { spawn Barrier }
					case 2 : { spawn Hill }
					case 3 : { spawn Ditch }
//					case 4 : { spawn Tunnel }
					default: { }
				}
			}
		}
	}
	
}

agent Barrier on Battleground {
	
	// returns x-coordinate
	passive GetX() : real => return xcor

	// returns y-coordinate
	passive GetY() : real => return ycor
	
}

agent Hill on Battleground { 

	observe var free : bool = true
	
	// returns x-coordinate
	passive GetX() => return xcor

	// returns y-coordinate
	passive GetY() => return ycor
	
	// returns whether hill is free
	passive IsFree() => return free
	
	// sets hill status to free
	passive Free() => free = true
	
	// sets hill status to occupied
	passive Occupy() => free = false
	
}

agent Ditch on Battleground { 
	
	observe var free : bool = true
	
	// returns x-coordinate
	passive GetX() => return xcor

	// returns y-coordinate
	passive GetY() => return ycor
	
	// returns whether ditch is free
	passive IsFree() => return free
	
	// sets ditch status to free
	passive Free() => free = true
	
	// sets ditch status to occupied
	passive Occupy() => free = false
	
}

// TODO: define attribute connectionPoint
//agent Tunnel on Battleground {
//	
//	// returns x-coordinate
//	passive GetX() => return xcor
//
//	// returns y-coordinate
//	passive GetY() => return ycor
//	
//}
