model lasertag

use Mars

grid-layer Battleground as battleground

// Team green
agent Green on Battleground {
	external var xSpawn : real
	external var ySpawn : real
	external observe var team : integer
	external observe var energy : integer
	external observe var actionPoints : integer
	// possible values: standing, kneeling, lying
	external observe var currStance : string
	external observe var movementRange : integer
	external observe var movementPoints : integer
	external observe var inGame : bool
	external observe var wasTagged : bool
	external observe var tagged : bool
	external observe var magazineCount : integer
	external observe var visualRange : real
	external observe var visibility : real
	var enemyList : Tuple<List<Red>, List<Blue>, List<Yellow>>
	var teamList : Green[]
	var wallList = new List<Wall>()
	// D* lite attributes
	external var spawnXCor : real
	external var spawnYCor : real
	var goalXCor : real
	var goalYCor : real
	var g : integer = 1000
	var rhs : integer = 1000
	var km : real = 0.0
	// tuple values: (<x>, <y>, <g>, <rhs>, <cost> <key1>, <key2>)
	var sStart : Tuple<real, real, integer, integer, integer, real, real>
	var sGoal : Tuple<real, real, integer, integer, integer, real, real>
	var sLast : Tuple<real, real, integer, integer, integer, real, real>
	var routeList = new List<Tuple<real, real, integer, integer, integer, real, real>>()
	var expandQueue = new List<Tuple<real, real, integer, integer, integer, real, real>>()
	var pathCalculated : bool = false
	
	initialize {
		var x = xSpawn as real
		var y = ySpawn as real
		pos at #(x, y)
	}
	
	tick {
		explore_walls()
		each (w in wallList) {
			println w
		}
	}
	
// **************************************************************************************** 
// *********************************** VISION BEGIN ***************************************
// ****************************************************************************************
	
	// implementation of Bresenham's Line Algorithm for obtaining a list of grid cells covered by a straight line between two points on the grid
	// http://tech-algorithm.com/articles/drawing-line-using-bresenham-algorithm/
	def hasBeeLine(x1 : real, y1 : real, x2 : real, y2 : real) : bool {
	    var hasBeeLine : bool = true
	    var x : integer = x1 as integer
	    var y : integer = y1 as integer
	    var newX2 : integer = x2 as integer
	    var newY2 : integer = y2 as integer
	    var w : integer = newX2 - x
	    var h : integer = newY2 - y
	    var dx1 : integer = 0
	    var dy1 : integer = 0
	    var dx2 : integer = 0
	    var dy2 : integer = 0
	    if (w < 0) {
	    	dx1 = -1
		} else if (w > 0) {
			dx1 = 1
		}
	    if (h < 0) {
	    	dy1 = -1
		} else if (h > 0) {
			dy1 = 1
		}
	    if (w < 0) {
	    	dx2 = -1
		} else if (w > 0) {
			dx2 = 1
		}
	    var longest : integer = Math.Abs(w)
	    var shortest : integer = Math.Abs(h)
	    if (not(longest > shortest)) {
	        longest = Math.Abs(h)
	        shortest = Math.Abs(w)
	        if (h < 0) {
	        	dy2 = -1
	    	} else if (h > 0) {
	    		dy2 = 1
	    	}
	        dx2 = 0          
	    }
	    var numerator : integer = longest / 2
	    for (var i=0; i <= longest; i++) {
	        println x + ", " + y
	        if (battleground.GetIntegerValue(x as real, y as real) === 1) {
				hasBeeLine = false
				return hasBeeLine
			}
	        numerator = numerator + shortest
	        if (not (numerator < longest)) {
	            numerator = numerator - longest
	            x = x + dx1
	            y = y + dy1
	        } else {
	            x = x + dx2
	            y = y + dy2
	        }
	    }
	    return hasBeeLine
	}

// **************************************************************************************** 
// ************************************ VISION END ****************************************
// ****************************************************************************************
	
// **************************************************************************************** 
// *********************************** D* LITE BEGIN **************************************
// ****************************************************************************************
	
	// main method for Guest pathfinding, movement, and path readjustment in case of unforeseen obstacles
	// xGoal: x-coordinate of grid cell Guest wants to move to
	// yGoal: y-coordinate of grid cell Guest wants to move to
	def goTo(xGoal : real, yGoal : real) : bool {
		if (battleground.GetIntegerValue(xGoal, yGoal) === 1) {
			return false
		}
		if (movementPoints < 1) {
			return false
		}
		// TODO: ist pathCalculated noch nötig?
		if (not pathCalculated) {
			initPathfinding(xGoal, yGoal)
		}
		sStart = findNextCell()
		if ((sStart.Item1 === -1.0) and (sStart.Item2 === -1.0)) {
			return false
		}
		var neighsInRouteList = findNeighsInRouteList()
		var neighsWithChangedCost = ScanCostChanges(neighsInRouteList)
		if (neighsWithChangedCost.Size() !== 0) {
			// calculation of completely new path
			var newExpandQueue = new List<Tuple<real, real, integer, integer, integer, real, real>>
			expandQueue = newExpandQueue
			var newRouteList = new List<Tuple<real, real, integer, integer, integer, real, real>>
			routeList = newRouteList
			var keyInit = Math.Max(Math.Abs(xcor - xGoal), Math.Abs(ycor - yGoal))
			sGoal = #(xGoal, yGoal, g, 0, battleground.GetIntegerValue(xGoal, yGoal), keyInit, 0.0)
			expandQueue.Add(sGoal)
			km = 0.0
			sStart = #(xcor, ycor, g, rhs, battleground.GetIntegerValue(xcor, ycor), 1000.0, 1000.0)
			sLast = sStart
			ComputeShortestPath(sStart, km)
			sStart = findNextCell()
		}
		move_me(sStart.Item1, sStart.Item2)
		if ((xcor === sGoal.Item1) and (ycor === sGoal.Item2)) {
			pathCalculated = false
		}
		return true
	}
	
	// initial method for pathfinding process and route planning
	// xGoal: x-coordinate of grid cell Guest wants to move to
	// yGoal: y-coordinate of grid cell Guest wants to move to
	def initPathfinding(xGoal : real, yGoal : real) {
		var costSStart = battleground.GetIntegerValue(xcor, ycor)
		sStart = #(xcor, ycor, g, rhs, costSStart, 1000.0, 1000.0)
		sLast = sStart
		var keyInit = Math.Max(Math.Abs(xcor - xGoal), Math.Abs(ycor - yGoal))
		var costSGoal = battleground.GetIntegerValue(xGoal, yGoal)
		sGoal = #(xGoal, yGoal, g, 0, costSGoal, keyInit, 0.0)
		expandQueue = new List<Tuple<real, real, integer, integer, integer, real, real>>
		routeList = new List<Tuple<real, real, integer, integer, integer, real, real>>
		expandQueue.Add(sGoal)
		ComputeShortestPath(sStart, km)
		pathCalculated = true
	}
	
	// computes shortest path from current position to goal
	// sStart: tuple representing grid cell from which Guest starts moving towards goal
	// km: key modifier value
	def ComputeShortestPath(sStart : Tuple<real, real, integer, integer, integer, real, real>, km : real) {
		var u : Tuple<real, real, integer, integer, integer, real, real> = GetTopKey()
		while ((u.Item6 !== 0.0) and ((u.Item6 < CalcKey1(sStart, km)) or (sStart.Item4 > sStart.Item3))) {
			var kOld1 = u.Item6
			var kNew1 = CalcKey1(u, km)
			var kNew2 = CalcKey2(u)
			if (kOld1 < kNew1) {
				var v = #(u.Item1, u.Item2, u.Item3, u.Item4, u.Item5, kNew1, kNew2)
				UpdateQueue(u, v)
			} else if (u.Item3 > u.Item4) {
				var uNew = #(u.Item1, u.Item2, u.Item4, u.Item4, u.Item5, u.Item6, u.Item7)
				routeList.Add(uNew)
				var NeighList = Neigh(uNew)
				Remove(u)
				each (var s in NeighList) {
					if ((s.Item1 !== sGoal.Item1) or (s.Item2 !== sGoal.Item2)) {
						var newRHS = RHS(s, uNew)
						var sNew = #(s.Item1, s.Item2, s.Item3, newRHS, s.Item5, s.Item6, s.Item7)
						UpdateVertex(sNew, km)
					}
				}
			} else {
				var gOld = u.Item3
				var uNew = #(u.Item1, u.Item2, g, u.Item4, u.Item5, u.Item6, u.Item7)
				UpdateQueue(u, uNew)
				var neighList = Neigh(uNew)
				neighList.Add(uNew)
				each (var s in neighList) {
					var updated : bool = false
					if (s.Item4 === (u.Item5 + gOld)) {
						if ((s.Item1 !== sGoal.Item1) or (s.Item2 !== sGoal.Item2)) {
							var neighListTemp = Neigh(s)
							var newRHS = getMinRHS(s, neighListTemp)
							var newS = #(s.Item1, s.Item2, s.Item3, newRHS, s.Item5, s.Item6, s.Item7)
							UpdateVertex(newS, km)
							updated = true
						}
					}
					if (not updated) {
						UpdateVertex(s, km)
					}
				}
			}
			u = GetTopKey()
		}
	}
	
	// determines which cell an Guest should move to next
	// return: tuple representing grid cell that Guest needs to move to
	def findNextCell() : Tuple<real, real, integer, integer, integer, real, real> {
		var nextCellCandidates = findNeighsInRouteList()
		if (nextCellCandidates.Size() === 0) {
			return #(-1.0, -1.0, 0, 0, 0, 0.0, 0.0)
		}
		var minNeigh = nextCellCandidates.Get(0)
		each (var neigh in nextCellCandidates) {
			if ((Cost(neigh, sStart) + neigh.Item3) < (Cost(minNeigh, sStart) + minNeigh.Item3)) {
				minNeigh = neigh
			} else if ((Cost(neigh, sStart) + neigh.Item3) === (Cost(minNeigh, sStart) + minNeigh.Item3)) {
				if ((xcor === neigh.Item1) or (ycor === neigh.Item2)) {
					minNeigh = neigh
				}
			}
		}
		return minNeigh
	}
	
	// creates a list of tuples representing grid cells that are neighbors of sStart and that are in routeList
	// return: list of tuples
	def findNeighsInRouteList() : List<Tuple<real, real, integer, integer, integer, real, real>> {
		var nextCellCandidates = new List<Tuple<real, real, integer, integer, integer, real, real>>()
		each (var s in routeList) {
			if (Heur(sStart, s) === 1.0) {
				nextCellCandidates.Add(s)
			}
		}
		return nextCellCandidates
	}
  
	// determines for all elements of List if their cost is not equal to 1.
	// List: neighbors of sStart
	// return: list with neighbors of sStart that are in routeList and whose cost is not equal to 1
	def ScanCostChanges(neighsinRouteList : List<Tuple<real, real, integer, integer, integer, real, real>>) : List<Tuple<real, real, integer, integer, integer, real, real>> {
		var currCostNeigh : integer
		var neighsWithChangedCost = new List<Tuple<real, real, integer, integer, integer, real, real>>()
		each(currNeigh in neighsinRouteList){
			currCostNeigh = Cost(currNeigh, sStart)
			if (currCostNeigh !== currNeigh.Item5) {
				neighsWithChangedCost.Add(currNeigh)
			}
		}
		return neighsWithChangedCost
	}
	
	// obtains the next cell that should be examined during pathfinding
	// return: tuple with most favorable key1 and key2
	def GetTopKey() : Tuple<real, real, integer, integer, integer, real, real> {
    	var minKey1 : real = expandQueue.Get(0).Item6
    	var minKey2 : real = expandQueue.Get(0).Item7
    	each (currElem in expandQueue) {
      		if (currElem.Item6 < minKey1) {
				minKey1 = currElem.Item6
				minKey2 = currElem.Item7
			} else if ((currElem.Item6 === minKey1) and (currElem.Item7 < minKey2)) {
				minKey2 = currElem.Item7
			}
		}
		var minKeyTuple : Tuple<real, real, integer, integer, integer, real, real>
		for (var i = 0; i < expandQueue.Size(); i++) {
			if ((expandQueue.Get(i).Item6 === minKey1) and (expandQueue.Get(i).Item7 === minKey2)) {
				minKeyTuple = expandQueue.Get(i)
				i = expandQueue.Size()
			}
		}
		return minKeyTuple
	}
	
	// calculates the first part of the key of a grid cell (using heuristic)
	// s: tuple for which key1 is to be calculated
	// km: key modifier value
	// return: key1 value of s
	def CalcKey1(s : Tuple<real, real, integer, integer, integer, real, real>, km : real) : real {
		return Math.Min(s.Item3, s.Item4) + Heur(sStart, s) + km
	}
	
	// heuristic: takes the larger value of the x-range and y-range between two grid cells
	// s1: tuple representing the first grid cell to be used in heuristic calculation
	// s2: tuple representing the second grid cell to be used in heuristic calculation
	// return: result of heuristic calculation
	def Heur(s1 : Tuple<real, real, integer, integer, integer, real, real>, s2 : Tuple<real, real, integer, integer, integer, real, real>) : real {
		return Math.Max(Math.Abs(s1.Item1 - s2.Item1), Math.Abs(s1.Item2 - s2.Item2))
	}
	
	// calculates the second part of the key of a grid cell
	// s: tuple for which key2 is to be calculated
	// return: key2 value of s
	def CalcKey2(s : Tuple<real, real, integer, integer, integer, real, real>) : real {
		var key2 : real = Math.Min(s.Item3, s.Item4)
		return key2
	}
	
	// updates expandQueue by calling remove method and adding a new tuple
	// u: tuple to be removed from expandQueue
	// newU: tuple to be added to expandQueue
	def UpdateQueue(u : Tuple<real, real, integer, integer, integer, real, real>, newU : Tuple<real, real, integer, integer, integer, real, real>) {
		Remove(u)
		expandQueue.Add(newU)
	}
	
	// updates routeList by creating a copy and adding s and all entries from old routeList unequal to s to it
	// s: new tuple to be added to routeList to replace old version of s
	def updateRouteList(s : Tuple<real, real, integer, integer, integer, real, real>) {
		var newRouteList = new List<Tuple<real, real, integer, integer, integer, real, real>>()
		each (var entry in routeList) {
			if ((entry.Item1 !== s.Item1) or (entry.Item2 !== s.Item2)) {
				newRouteList.Add(entry)
			}
			if ((entry.Item1 === s.Item1) and (entry.Item2 === s.Item2)) {
				newRouteList.Add(s)
			}
		}
		routeList = newRouteList
	}
	
	// removes a tuple from expandQueue
	// u: tuple to be removed from expandQueue
	def Remove(u : Tuple<real, real, integer, integer, integer, real, real>) {
		var newExpandQueue = new List<Tuple<real, real, integer, integer, integer, real, real>>()
		each (var s in expandQueue) {
			if ((s.Item1 !== u.Item1) or ((s.Item2 !== u.Item2))) {
				newExpandQueue.Add(s)
			}
		}
		expandQueue = newExpandQueue
	}
	
	// finds all grid cells neighboring s (and whether they have representative tuples in routeList or expandQueue)
	// s: tuple representing grid cell of which neighbors are to be found
	// return: list containing tuples representing neighbors of s
	def Neigh(s : Tuple<real, real, integer, integer, integer, real, real>) : List<Tuple<real, real, integer, integer, integer, real, real>> {
		var NeighList = new List<Tuple<real, real, integer, integer, integer, real, real>>()
		// TODO: durch inQueue-Aufrufe ersetzen
		var x : real
		var y : real
		for (x = s.Item1 - 1.0; x <= s.Item1 + 1.0; x++) {
			for (y = s.Item2 - 1.0; y <= s.Item2 + 1.0; y++) {
				if ((x !== s.Item1) or (y !== s.Item2)) {
					var found : bool = false
					each (r in routeList) {
						if ((r.Item1 === x) and (r.Item2 === y)) {
							NeighList.Add(r)
							found = true
						}
					}
					each (e in expandQueue) {
						if ((e.Item1 === x) and (e.Item2 === y)) {
							NeighList.Add(e)
							found = true
						}
					}
					if (not found) {
						var neigh = #(x, y, g, rhs, 0, 1000.0, 1000.0)
						var costNeigh = Cost(neigh, s)
						if (costNeigh !== 1000) {
							var newNeigh = #(x, y, g, rhs, costNeigh, 1000.0, 1000.0)
							NeighList.Add(newNeigh)
						}
					}
				}
			}
		}
		return NeighList
	}
	
	// calculates the rhs value of tuple based on another tuple
	// s: tuple representing grid cell neighboring u
	// u: tuple representing grid cell currently being examined
	// return: updated rhs value
	def RHS(s : Tuple<real, real, integer, integer, integer, real, real>, u : Tuple<real, real, integer, integer, integer, real, real>) : integer {
		if ((s.Item1 === sStart.Item1) and (s.Item2 === sStart.Item2)) {
			return 0
		} else {
			var newRHS : integer = Math.Min(s.Item4, (Cost(u, s) + u.Item3))
			return newRHS
		}
	}
	
	// updates tuple u by adding it to or removing it from expandQueue or changing its information
	// u: tuple to be updated
	// km: key modifier value
	// TODO: km aus args entfernen?
	def UpdateVertex(u : Tuple<real, real, integer, integer, integer, real, real>, km : real) {
		var isInQueue : bool = inQueue(u)
		var newKey1 = CalcKey1(u, km)
		var newKey2 = CalcKey2(u)
		if ((u.Item3 !== u.Item4) and isInQueue) {
			var uNew = #(u.Item1, u.Item2, u.Item3, u.Item4, u.Item5, newKey1, newKey2)
			UpdateQueue(u, uNew)
		} else if ((u.Item3 !== u.Item4) and (not isInQueue)) {
			var uNew = #(u.Item1, u.Item2, u.Item3, u.Item4, u.Item5, newKey1, newKey2)
			expandQueue.Add(uNew)
		} else if ((u.Item3 === u.Item4) and (isInQueue)) {
			routeList.Add(u)
			Remove(u)
		}
	}
	
	// checks if a tuple is in expandQueue
	// u: tuple to be checked
	// return: boolean
	def inQueue(u : Tuple<real, real, integer, integer, integer, real, real>) : bool {
		each (element in expandQueue) {
			if ((element.Item1 === u.Item1) and (element.Item2 === u.Item2)) {
				return true
			}
		}
		return false
	}
	
	// checks if a tuple is in routeList
	// u: tuple to be checked
	// return: boolean
	def inRouteList(u : Tuple<real, real, integer, integer, integer, real, real>) : bool {
		each (element in routeList) {
			if ((element.Item1 === u.Item1) and (element.Item2 === u.Item2)) {
				return true
			}
		}
		return false
	}
	
	// TODO: remove from algorithm!
	// computes cost of moving from s to u and checks numeric value of s on grid layer
	// s: tuple representing the first grid cell to be used in cost calculation
	// u: tuple representing the second grid cell to be used in cost calculation
	// return: cost value on s
	def Cost(s : Tuple<real, real, integer, integer, integer, real, real>, u : Tuple<real, real, integer, integer, integer, real, real>) : integer {
		var dist = Heur(s, u)
		if (dist === 1.0) {
			if (battleground.GetIntegerValue(s.Item1, s.Item2) !== 0) {
				return 1000
			} 
			else {
				return 1
//				var cellCost = battleground.GetIntegerValue(s.Item1, s.Item2)
//				var guestList = explore Guest where [x => return ((x.X() !== xcor) and (x.Y() !== ycor))]
//				var guestCost : integer
//				each (guest in guestList) {
//					 var closeness : real = Math.Max(Math.Abs(guest.X() - s.Item1), Math.Abs(guest.Y() - s.Item2))
//					 if (closeness < 1.0) {
//					 	guestCost = guestCost + perimeterCost
//					 }
//					 if (closeness <= minSafetyDist) {
//					 	guestCost = guestCost + perimeterCost
//					 }
//				}
//				var result : integer = cellCost + guestCost
//				return result
			}
		} else if (dist < 1.0) {
			return 0
		} else {
			println("s and u are not neighbors!")
		}
		return 1
	}
	
	// obtains minimum rhs-value of all neighbors of s
	// s: tuple representing grid cell whose neighbors minimum rhs value is to be determined
	// neighListTemp: list of tuples representing grid cells that neighbor s
	// return: smallest rhs values among neighbors of s
	def getMinRHS(s : Tuple<real, real, integer, integer, integer, real, real>, neighListTemp: List<Tuple<real, real, integer, integer, integer, real, real>>) : integer {
		var minRHS = neighListTemp.Get(0).Item3 + Cost(neighListTemp.Get(0), s)
		each (var neigh in neighListTemp) {
			var compRHS : integer = neigh.Item3 + Cost(neigh, s)
			if (compRHS < minRHS) {
				minRHS = compRHS
			}
		}
		return minRHS
	}
	
	// prints a list of tuples
	// list: list of tuples to be printed
	def printQueue(list : List<Tuple<real, real, integer, integer, integer, real, real>>) {
		each (element in list) {
			println(element)
		}
	}

// **************************************************************************************** 
// ************************************ D* LITE END ***************************************
// ****************************************************************************************
	
	// moves agent, if possible, one grid cell in the direction specified by the input parameter <direction>
	// TODO: implement a pathfinding algorithm (D*-algorithm?)
	def move_me(x : real, y : real) {
		move me to #(x, y)
		movementPoints = movementPoints - 1
	}

	// refills actionPoints and movementPoints
	// TODO: consider designing different solution for refilling points (to avoid having to touch tick methods)
	def refill_points() {
		actionPoints = 10
		movementPoints = movementRange
	}
	
	// changes currStance to <newStance>
	def change_stance(newStance : string) {
		if (actionPoints < 2) {
			return
		}
		if (newStance === currStance) {
			return
		}
		currStance = newStance
		actionPoints = actionPoints - 2
		switch (currStance) {
			case "standing": {
				visualRange = 10
				visibility = 10
				movementRange = 6
			}
			case "kneeling": {
				visualRange = 8
				visibility = 8
				movementRange = 3
			}
			case "lying": {
				visualRange = 5
				visibility = 5
				movementRange = 1
			}
		}
	}
	
	// exploration of the environment occurs in three phases: 1) team members, 2) walls, 3) enemies
	def explore_env() {
		actionPoints = actionPoints - 1
		explore_team()
		explore_walls()
		//explore_enemies()
	}
	
	// TODO: share each other's enemy lists during explore_team()
	// generates a list of coordinates of all team members
	def explore_team() {
		teamList = explore Green
	}
	
	// generates a list of coordinates within visualRange that contain a wall
	// TODO: fix exploration so that agent can't detect walls located behind walls (do cost-benefit analysis for this task)
	def explore_walls() {
		wallList = new List<Wall>
		var tempWallList = explore Wall
//		where [w => return ((distance w) <= visualRange)]
		each (w in tempWallList) {
			println(w)
		}
		each (w in tempWallList) {
			if (hasBeeLine(xcor, ycor, w.GetX(), w.GetY())) {
				wallList.Add(w)
			}
		}
	}
	
	// generates lists of coordinates of all enemies within visualRange
	// three conditions for being able to see an enemy:
		// 1) enemy coordinates are within visualRange
		// 2) enemy visibility makes enemy visible from my location
		// 3) there are no walls blocking linear vision between enemy and me
	// TODO: automatically forward enemy locations to other team members
	def explore_enemies() {
		// generate lists with enemies who satisfy conditions 1 and 2
		var red = explore Red where [x => return (distance x) <= visualRange and (distance x) <= x.GetVisibility and hasBeeLine(xcor, ycor, x.GetX(), x.GetY())]
		var blue = explore Blue where [x => return (distance x) <= visualRange and (distance x) <= x.GetVisibility and hasBeeLine(xcor, ycor, x.GetX(), x.GetY())]
		var yellow = explore Yellow where [x => return (distance x) <= visualRange and (distance x) <= x.GetVisibility and hasBeeLine(xcor, ycor, x.GetX(), x.GetY())]
		enemyList = #(new List<Red>, new List<Blue>, new List<Yellow>)
		var redList = enemyList.Item1
		var blueList = enemyList.Item2
		var yellowList = enemyList.Item3
		each (r in red) {
			redList.Add(r)
		}
		each (b in blue) {
			blueList.Add(b)
		}
		each (y in yellow) {
			yellowList.Add(y)
		}
	}

	// tags an enemy whose coordinates are in enemyList
	def tag() {
		
	}
	
	// refills magazineCount
	def reload() {
		
	}
	
	// returns current visibility value to the caller
	passive GetVisibility() : real {
		return visibility
	}
	
	// returns current x-coordinate to the caller
	passive GetX() : real {
		return xcor
	}
	
	// returns current y-coordinate to the caller
	passive GetY() : real {
		return ycor
	}
	
}

// Team red
agent Red on Battleground {

	external observe var visibility : real
	
	// returns current visibility value to the caller
	passive GetVisibility() => return visibility
	
	// returns current x-coordinate to the caller
	passive GetX() => return xcor
	
	// returns current y-coordinate to the caller
	passive GetY() => return ycor
	
}

// Team blue
agent Blue on Battleground {

	external observe var visibility : real
	
	// returns current visibility value to the caller
	passive GetVisibility() => return visibility
	
	// returns current x-coordinate to the caller
	passive GetX() => return xcor
	
	// returns current y-coordinate to the caller
	passive GetY() => return ycor
	
}

// Team yellow
agent Yellow on Battleground {

	external observe var visibility : real
	
	// returns current visibility value to the caller
	passive GetVisibility() => return visibility
	
	// returns current x-coordinate to the caller
	passive GetX() => return xcor
	
	// returns current y-coordinate to the caller
	passive GetY() => return ycor
	
}

// ************************************************************************************************
// *************************************** SECONDARY AGENTS ***************************************
// ************************************************************************************************

agent Spawner on Battleground {

	tick { }
	
	initialize { 
		println "init"
		pos me at #(0,0)	
		for(var x = 0; x < battleground.DimensionX; x++) {
			for(var y = 0; y < battleground.DimensionY; y++) {
				pos me at #(x, y)
				var v : integer = battleground.GetIntegerValue(x, y)
				switch (v) {
					case 1 : {
						spawn Wall
					}
					default: { }
				}
			}
		}
	}
}

agent Wall on Battleground {
	
	passive GetX() => return xcor
	passive GetY() => return ycor
	
}

//agent Hill on Battleground { }
//
//agent Ditch on Battleground { }
//
//// TODO: define attribute connectionPoint
//agent Tunnel on Battleground { }
