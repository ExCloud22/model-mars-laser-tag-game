model lasertag

grid-layer Battleground as battleground

enum stance {
	Standing, Kneeling, Lying
}

agent green on Battleground{
	observe var energy : integer = 100
	observe var actionPoints : integer = 10
	observe var currStance = stance.Standing
	observe var inGame : bool = true
	observe var wasTagged : bool = false
	observe var tagged : bool = false
	observe var magazineCount : integer = 5
	observe var visualRange : real = 2
	observe var visibility : real = 10
	//TODO: Liste der richtigen Feinde. Benötigen wir verschiedene agents?
	var enemyList : Tuple<List<red>,[blue],[yellow]>
	var teamList : [green]
	var wallList : List<Tuple<real, real>>
	var redList = new List<red>
	
	initialize {
		// pos at #(random(battleground.DimensionX),random(battleground.DimensionY)) 
		pos at #(1,1) 
	}
	
	tick {
		//move_me()	
		
		
		// var tuple : Tuple<integer, integer> = #(2, 3)
		//enemyList.Add(#(xcor, ycor))
		
		//enemy_x = enemyList.Get(0).Item1
		//enemy_y = enemyList.Get(0).Item2
		//change_stance(stance.Kneeling)
		explore_env()
		move me right
		refill_action_points()
	}	
	
	// TODO: Andere Lösung zum auffüllen der Punkte finden
	def refill_action_points(){
		actionPoints = 10
	}
	
	//TODO: Punkte müssen zentral verwaltet werden
	// Wenn genug Punkte vorhanden wird die Position geändert (Kosten 2 Punkte)
	def change_stance(newStance : stance) {
		if (actionPoints < 2) {
			return
		}
		currStance = newStance
		actionPoints = actionPoints - 2
		switch (currStance) {
			case stance.Standing: {
				visualRange = 10
				visibility = 10
			}
			case stance.Kneeling: {
				visualRange = 8
				visibility = 8
			}
			case stance.Lying: {
				visualRange = 5
				visibility = 5
			}
		}
	}
	def explore_env() {
		explore_team()
		explore_enemies()
		explore_walls()
		
	}
	def explore_walls(){
		// Speichert alle in visualRange befindlichen Wände in wallList
		wallList = new List<Tuple<real, real>>
		for(var x = xcor - visualRange; x <= xcor + visualRange; x++){
			for(var y = ycor + visualRange; y >= ycor - visualRange; y--){
				if (battleground.GetIntegerValue(x,y) === 1) {
					wallList.Add(#(x,y))
					println #(x,y)
				}
				
			}
		}
	}
	def explore_team(){
		// Aktualisiert die Teammitglieder-Liste
		teamList = explore green
	}
	// TODO: Gegnerposition an Team automatisch weitergeben
	def explore_enemies(){
		// Agenten werden hinzugefügt wenn sie in Sichtweite sind
		var tmpRed = explore red where [x => return (distance x) <= visualRange and (distance x) <= x.GetVisibility]
		var tmpBlue = explore blue where [x => return (distance x) <= visualRange and (distance x) <= x.GetVisibility]
		var tmpYellow = explore yellow where [x => return (distance x) <= visualRange and (distance x) <= x.GetVisibility]
		//TODO: redList = new List<red>()
		// (Blockiert, meine Stellung, Gegner Stellung)
		// TODO: Blockierung durch Env. prüfen
		each (red in tmpRed) {
			// Enemy Vertikal von mir
			if (xcor === red.GetX) {
				// Enemy unter mir
				if (ycor > red.GetY) {
					each (wall in wallList) {
						// Keine Wand zwischen enemy und mir
						if (not(wall.Item1 === xcor and wall.Item2 > red.GetY and wall.Item2 < ycor)) {
							redList.Add(red)
						}
					}
				}
				// Enemy über mir
				if (ycor < red.GetY) {
					each (wall in wallList) {
						// Keine Wand zwischen enemy und mir
						if (not(wall.Item1 === xcor and wall.Item2 < red.GetY and wall.Item2 > ycor)) {
							redList.Add(red)
						}
					}
				}
			// Enemy Horizontal von mir
			}else if (ycor === red.GetY) {
				// Enemy Links von mir
				if (xcor > red.GetX) {
					each (wall in wallList) {
						// Keine Wand zwischen enemy und mir
						if (not(wall.Item2 === ycor and wall.Item1 > red.GetX and wall.Item1 < xcor)) {
							redList.Add(red)
						}
					}
				}
				// Enemy Rechts von mir
				if (xcor < red.GetX) {
					each (wall in wallList) {
						// Keine Wand zwischen enemy und mir
						if (not(wall.Item2 === ycor and wall.Item1 < red.GetX and wall.Item1 > xcor)) {
							redList.Add(red)
						}
					}
				}
				
			} else {
				
			}
		}
		enemyList = #(redList, tmpBlue, tmpYellow)
	}
	def move_me() {
		switch (random(8)) {
			case 0 : { move 1 up} // north
			case 1 : { move 1 up-right} // north-east
			case 2 : { move 1 right} // east
			case 3 : { move 1 down-right} // south-east
			case 4 : { move 1 down} // south
			case 5 : { move 1 down-left} // south-west
			case 6 : { move 1 left} // west
			case 7 : { move 1 up-left} // north-west
		}
	}
	def shoot(){
		
	}
	
	passive GetVisibility() : real {
		return visibility
	}
	passive GetX() : real {
		return xcor
	}
	passive GetY() : real {
		return ycor
	}
}

agent red on Battleground {
	observe var energy : integer = 100
	observe var actionPoints : integer = 10
	observe var currStance = stance.Standing
	observe var inGame : bool = true
	observe var wasTagged : bool = false
	observe var tagged : bool = false
	observe var magazineCount : integer = 5
	observe var visualRange : real = 10
	observe var visibility : real = 10
	//TODO: Liste der richtigen Feinde. Benötigen wir verschiedene agents?
	var enemyList : Tuple<[green],[blue],[yellow]> = nil
	var teamList = new List<red>()
	observe var targetDistance : real
	
	initialize {
		pos at #(3,1) 
	}
	
	tick {
		//random_walk()	
		change_stance(stance.Kneeling)	
		
		refill_action_points()
	}	
	def refill_action_points(){
		actionPoints = 10
	}
	
	//TODO: Punkte müssen zentral verwaltet werden
	// Wenn genug Punkte vorhanden wird die Position geändert (Kosten 2 Punkte)
	def change_stance(newStance : stance) {
		if (actionPoints < 2) {
			return
		}
		currStance = newStance
		actionPoints = actionPoints - 2
	}
	def random_walk() {
		switch (random(8)) {
			case 0 : { move 1 up} // north
			case 1 : { move 1 up-right} // north-east
			case 2 : { move 1 right} // east
			case 3 : { move 1 down-right} // south-east
			case 4 : { move 1 down} // south
			case 5 : { move 1 down-left} // south-west
			case 6 : { move 1 left} // west
			case 7 : { move 1 up-left} // north-west
		}
	}
	passive GetVisibility() : real {
		return visibility
	}
	passive GetX() : real {
		return xcor
	}
	passive GetY() : real {
		return ycor
	}
}

agent blue on Battleground {
	observe var energy : integer = 100
	observe var actionPoints : integer = 10
	observe var currStance = stance.Standing
	observe var inGame : bool = true
	observe var wasTagged : bool = false
	observe var tagged : bool = false
	observe var magazineCount : integer = 5
	observe var visualRange : real = 10
	observe var visibility : real = 10
	//TODO: Liste der richtigen Feinde. Benötigen wir verschiedene agents?
	var enemyList : Tuple<[red],[green],[yellow]> = nil
	var teamList = new List<blue>()
	observe var targetDistance : real
	
	initialize {
		pos at #(random(battleground.DimensionX),random(battleground.DimensionY)) 
	}
	
	tick {
		random_walk()	
		change_stance(stance.Kneeling)	
		
		refill_action_points()
	}	
	def refill_action_points(){
		actionPoints = 10
	}
	
	//TODO: Punkte müssen zentral verwaltet werden
	// Wenn genug Punkte vorhanden wird die Position geändert (Kosten 2 Punkte)
	def change_stance(newStance : stance) {
		if (actionPoints < 2) {
			return
		}
		currStance = newStance
		actionPoints = actionPoints - 2
	}
	def random_walk() {
		switch (random(8)) {
			case 0 : { move 1 up} // north
			case 1 : { move 1 up-right} // north-east
			case 2 : { move 1 right} // east
			case 3 : { move 1 down-right} // south-east
			case 4 : { move 1 down} // south
			case 5 : { move 1 down-left} // south-west
			case 6 : { move 1 left} // west
			case 7 : { move 1 up-left} // north-west
		}
	}
	passive GetVisibility() : real {
		return visibility
	}
}

agent yellow on Battleground {
	observe var energy : integer = 100
	observe var actionPoints : integer = 10
	observe var currStance = stance.Standing
	observe var inGame : bool = true
	observe var wasTagged : bool = false
	observe var tagged : bool = false
	observe var magazineCount : integer = 5
	observe var visualRange : real = 10
	observe var visibility : real = 10
	//TODO: Liste der richtigen Feinde. Benötigen wir verschiedene agents?
	var enemyList : Tuple<[red],[blue],[green]> = nil
	var teamList = new List<yellow>()
	observe var targetDistance : real
	
	initialize {
		pos at #(random(battleground.DimensionX),random(battleground.DimensionY)) 
	}
	
	tick {
		random_walk()	
		change_stance(stance.Kneeling)	
		
		refill_action_points()
	}	
	def refill_action_points(){
		actionPoints = 10
	}
	
	//TODO: Punkte müssen zentral verwaltet werden
	// Wenn genug Punkte vorhanden wird die Position geändert (Kosten 2 Punkte)
	def change_stance(newStance : stance) {
		if (actionPoints < 2) {
			return
		}
		currStance = newStance
		actionPoints = actionPoints - 2
	}
	def random_walk() {
		switch (random(8)) {
			case 0 : { move 1 up} // north
			case 1 : { move 1 up-right} // north-east
			case 2 : { move 1 right} // east
			case 3 : { move 1 down-right} // south-east
			case 4 : { move 1 down} // south
			case 5 : { move 1 down-left} // south-west
			case 6 : { move 1 left} // west
			case 7 : { move 1 up-left} // north-west
		}
	}
	passive GetVisibility() : real {
		return visibility
	}
}
