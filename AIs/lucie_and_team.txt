	tick {
		var oldStage : integer = 0
		var moved : bool = false
		var enemyInSight : bool = false
		var encounteredEnemies : bool = wasTagged 
		var hasGoal : bool = (stage !== 0 and sGoal != nil and sGoal.Item1() !== xcor and sGoal.Item2() !== ycor)
		var strategy : integer = 0
		var pois : List<Tuple<real, real>> = new List<Tuple<real, real>>
		var poi : Tuple<real, real>
		var isRectangle : bool = false
		var flee : bool = false
		var rememberedX = -1
		var rememberedY = -1
		
		if(stage === 0){
			hasGoal = true
			isRectangle = goTo(50,26)
		}
		
		if(stage >= 200000000){ // not >= 100000000 so that negative values remain possible
			isRectangle = true
			stage = stage - 1000000000
		}
		
		changeStance("standing")
		
		if(stage === 0 or stage === 77){
			stage = 1 // since sGoal does not get reset at respawn
		} else if (stage < 0) {
			changeStance("standing")
			goTo(xSpawn, ySpawn)
			stage = stage + 1
			hasGoal = true
			changeStance("lying")
		}


		// where are the enemies?
		var enemies = exploreEnemies()
		enemyInSight = (length(enemies.Item1()) > 0 or length(enemies.Item2()) > 0 or length(enemies.Item3()) > 0)
		var enemyInTeamsSight = enemiesFromTeam.Size > 0
		var enemyEncountered = enemyInTeamsSight or enemyInSight or wasTagged

		//explore and choose strategy
		if(not enemyEncountered){
			// recall "short-term memory"
			if(stage > 100000000){
				var fromMemoryY: real = stage % 10000
				var fromMemoryX: real = ((stage - fromMemoryY) / 10000) % 10000
				poi = #(fromMemoryX, fromMemoryY)
				stage = 1
				moved = goTo(fromMemoryX, fromMemoryY)

			} else if(not hasGoal){
			// choosing strategy
			
				strategy = (random(3) + 1) * 10 // 10,20, 30 
							
				if(strategy === 10) {
					exploreEnv("ditches")
					pois = ditches
				}
				if(strategy === 20) {
					exploreEnv("hills")
					pois = hills
				}
				if(pois.Size > 0){
					var randNum = random(pois.Size - 1)
					poi = pois.Get(randNum)
				} else {
					strategy = 30
				}
				if(strategy === 30) {
					var randX : real = random(battleground.DimensionX-2) + 1
					var randY : real = random(battleground.DimensionY-2) + 1
					poi = #(randX, randY)
				}
				moved = goTo(poi.Item1(), poi.Item2())
			} else {
				// pursue goal
				poi = #(sGoal.Item1(), sGoal.Item2())
				moved = goTo(poi.Item1(), poi.Item2())
				if(not moved){
					stage = 77
				}
			}
			
			// shoot at occupied POI
			var poiIsOccupied = (not moved and hasMoved and strategy !== 30)
			if(poiIsOccupied and hasBeeline(poi.Item1, poi.Item2)){
				tag(poi.Item1, poi.Item2)
			}
		}

		
		// war mode
		if(enemyInSight) {
			if((length(enemies.Item1()) + length(enemies.Item2()) + length(enemies.Item3()) > enemiesFromTeam.Size) and not hasMoved and stage >= 0){
				// fight only if majority is likely
				flee = true
			} else {
				changeStance("lying")
				each(enemy in enemies.Item1()){ tag(enemy) }
				each(enemy in enemies.Item2()){ tag(enemy) }
				each(enemy in enemies.Item3()){ tag(enemy) }
				// stand up only if no enemies in sight or if we must flee; otherwise, we might stand again when enemy shoots
			}
		} else if(enemyInTeamsSight){
			var myEnemies : List<Tuple<real, real>> = new List<Tuple<real, real>>
			var enemyPosition : Tuple<real, real>
			var shoot : bool
			// explore all enemies within sight
			for(var i = 0;i < enemiesFromTeam.Size; i++){
				enemyPosition = enemiesFromTeam.Get(i)
				if(hasBeeline(enemyPosition.Item1(), enemyPosition.Item2())){
					myEnemies.Add(enemyPosition)
				}
			}
			if(myEnemies.Size > 0){
				// enemy in line of sight -> shoot
				shoot = true
			} else {
				// enemy not in line of sight
				shoot = false
				for(var i = 0; i < enemiesFromTeam.Size; i++){
					enemyPosition = enemiesFromTeam.Get(i)
					myEnemies.Add(enemyPosition)
				}
			}
			// who is next?
			var distanceToCurrentEnemy : real
			var closestEnemy : Tuple<real, real> = myEnemies.Get(0)
			var distanceToClosestEnemy = Math.Sqrt((closestEnemy.Item1() - xcor)**2 + (closestEnemy.Item2() - ycor)**2)
			each (enemy in myEnemies){
				distanceToCurrentEnemy = Math.Sqrt((enemy.Item1() - xcor)**2 + (enemy.Item2() - ycor)**2)
				if(distanceToCurrentEnemy < distanceToClosestEnemy){
					closestEnemy = enemy
					distanceToClosestEnemy = distanceToCurrentEnemy
				}
			}
			
			if(shoot){
				tag(closestEnemy.Item1(), closestEnemy.Item2())
				tag(closestEnemy.Item1(), closestEnemy.Item2())
			} else {
				// Probieren einen Schritt schräg auf den Gegner zu zugehen und dann zu schießen
				var newX = 1
				var newY = 1 
				if((xcor - closestEnemy.Item1()) === 0) {
					if(random(1) > 0){ newX = newX*(-1) }
				}
				if((ycor - closestEnemy.Item2()) === 0) {
					if(random(1) > 0){ newY = newY*(-1) }
				}
				if((xcor - closestEnemy.Item1()) !== 0 and (ycor - closestEnemy.Item2()) !== 0) {
					if(random(1) > 0){
						newX = 0
						if(random(1) > 0){ newY = newY*(-1) }
					} else {
						newY = 0
						if(random(1) > 0){ newX = newX*(-1) }
					}
				}
				goTo(xcor+newX, ycor+newY)
				tag(closestEnemy.Item1(), closestEnemy.Item2())
			}
			// fill up "short-term memory"
			rememberedX = closestEnemy.Item1() as integer
			rememberedY = closestEnemy.Item2() as integer
		}
		
		// Get to da choppa
		// flee if 'flee' was previously set to true of if we get attacked and don't see anyone
		if(stage >= 0 and (flee or (wasTagged and not enemyInSight and not enemyInTeamsSight))){
			if(not hasMoved){
				goTo(xSpawn, ySpawn)
				changeStance("lying")
				stage = -10
			} else {
				changeStance("lying")
				stage = -10
			}
		}
		
		if(rememberedX !== -1){
			stage = 100000000 + (rememberedX * 10000) + rememberedY
		}

		refillPoints()
	}