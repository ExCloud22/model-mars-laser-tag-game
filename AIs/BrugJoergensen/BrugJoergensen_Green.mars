	tick {
		// unpack stage
		var ts = stage
		var vz : integer = 1	// -1 || 1
		if(ts < 0){
		vz = vz * -1
		ts = ts * -1
		}
		var state : integer = ts/100000000 // 0-20
		ts = ts - state*100000000
		var xpos : integer = ts/1000000	// 0-99
		ts = ts - xpos*1000000
		var ypos : integer = ts/10000	// 0-99
		ts = ts - ypos*10000
		var arg1 : integer = ts/1000	// 0-9
		ts = ts - arg1*1000
		var arg2 : integer = ts/100	// 0-9
		ts = ts - arg2*100
		var arg3 : integer = ts/10	// 0-9
		ts = ts - arg3*10
		var arg4 : integer = ts	// 0-9
		ts = ts - arg4
		
		
		// main cases:
		var oxcor = xcor
		var oycor = ycor
		
		var loop : bool = true
		var mainloopcount = 0
		
		var enemies : Tuple<Red[], Blue[], Yellow[]> = nil
		//var enemyCount : integer = length(enemies.Item1) + length(enemies.Item2) + length(enemies.Item3)
		var enemyCount = 0
		
		var debug : bool = false
		
		while(actionPoints > 0 and loop and mainloopcount < 20){
			if (debug){println(memberID + " | " + state + "  ||  " + stage)}
			//if (debug){println("spotted " + enemyCount +" enemies!")}
			// stage 0
			// SelectMoveToTarget
			if(state === 0){
				changeStance("standing")
				exploreEnv("barriers")
				exploreEnv("hills")
				exploreEnv("ditches")
				//xpos = xcor as integer
				//ypos = ycor as integer
				var tpos : Tuple<real,real> = #(xcor + random(3)-1,ycor + random(3)-1)
				var posdist : real = -1.0
				enemies = exploreEnemies()
				enemyCount = length(enemies.Item1) + length(enemies.Item2) + length(enemies.Item3)
				if(arg2 < enemyCount){
					if (debug){println("ENEMYDETECTED STATE 1")}
					state = 1
				}else if((enemiesFromTeam.Size() > 0) and (random(6) !== 1)){
					if (debug){println("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++FOLLOW MODE")}
					state = 1
					var coord = enemiesFromTeam.Get(random(enemiesFromTeam.Size()-1))
					xpos = coord.Item1 as integer
					ypos = coord.Item2 as integer
					arg1 = 0
					arg2 = 0
					arg3 = 0
					arg4 = 0
					if(hasBeeline(coord.Item1,coord.Item2) and (random(5) < 2)){
						state = 11
					}
				}else{
					if(arg1 === 0 and (hills.Size() > 0 or ditches.Size() > 0)){
						if (debug){println(memberID + " _ 1")}
						each(var h in hills){
							var pd = ((xcor - h.Item1)**2 + (ycor - h.Item2)**2)**0.5
							if(pd > posdist and pd > 3.0){
								posdist = pd
								tpos = h
							}
						}
						each(var d in ditches){
							var pd = ((xcor - d.Item1)**2 + (ycor - d.Item2)**2)**0.5
							if(pd > posdist and pd > 3.0){
								posdist = pd
								tpos = d
							}
						}
						if (debug){println(memberID+" -- Ditches : "+ditches.Size())}
						state = 1
						xpos = tpos.Item1 as integer
						ypos = tpos.Item2 as integer
						arg1 = 0
						arg2 = 0
						arg3 = 0
						arg4 = 0
					}else if((arg1 === 0) or (battleground.GetIntegerValue(xpos,ypos) === 1) or ((xcor === (xpos as real)) and (ycor === (ypos as real)))){
						if (debug){println(memberID + " _ 2")}
						each(var b in barriers){
							var pd = ((xcor - b.Item1)**2 + (ycor - b.Item2)**2)**0.5
							if(pd > posdist){
								posdist = pd
								tpos = b
							}
						}
						var ntpos = tpos
						while(battleground.GetIntegerValue(ntpos.Item1,ntpos.Item2) === 1){
							ntpos = #(Math.Min(battleground.DimensionX - 1, Math.Max(0, tpos.Item1+random(11)-6)) as real, Math.Min(battleground.DimensionY - 1, Math.Max(0, tpos.Item2+random(11)-6)) as real)
						}
						xpos = ntpos.Item1 as integer
						ypos = ntpos.Item2 as integer
						if (debug){println(memberID+" > "+xpos+" "+ypos+" | "+xcor+" "+ycor)}
						goTo(xpos as real,ypos as real)
						arg1 = 3 + random(6)
						changeStance("lying")
						loop = false
					}else{
						if (debug){println(memberID + " _ 3")
						println(memberID+"|> "+xpos+" "+ypos+" | "+xcor+" "+ycor)}
						goTo(xpos as real,ypos as real)
						changeStance("lying")
						arg1 = arg1 - 1
						loop = false
					}
				}
				arg1 = Math.Min(9, Math.Max(0,arg1))
			}
			
			// stage 1
			// MoveTo
			if(state === 1){
				changeStance("standing")
				enemies = exploreEnemies()
				enemyCount = length(enemies.Item1) + length(enemies.Item2) + length(enemies.Item3)
				if((enemyCount === 0) and (battleground.GetIntegerValue(xpos, ypos) !== 1)){
					var x = xpos as real
					var y = ypos as real
					while(battleground.GetIntegerValue(x,y) === 1){
						x = Math.Min(battleground.DimensionX - 1, Math.Max(0, x+random(7)-4)) as real
						y = Math.Min(battleground.DimensionY - 1, Math.Max(0, y+random(7)-4)) as real
					}
					goTo(x,y)
					enemies = exploreEnemies()
					enemyCount = length(enemies.Item1) + length(enemies.Item2) + length(enemies.Item3)
				}else{
					if (debug){println("MOVE TO :"+xpos+" "+ypos+" | "+enemyCount)}
				}
				if(enemyCount === 1){
					state = 10
				}else if(enemyCount > 1){
					state = 2
				}else if(xcor === (xpos as real) and ycor === (ypos as real)){
					state = 0
					arg1 = 0
					arg2 = 0
					arg3 = 0
					arg4 = 0
				}else{
					loop = false
					if (debug){println("STATE 1 EC = "+enemyCount+" | POS = "+xpos+";"+ypos+" | COR = "+xcor+";"+ycor)}
				}
				
			}
			
			// stage 2
			// *********************************************************************
			// MULTIENEMYACTION - STAGE 2
			// Agent explored more than one enemy and tries to get into cover
			// search through all known cover fields and check if closest field is 
			// reachable. (if there is enough time left to survive)
			if(state === 2){
				if (debug){println("Explored more enemies!")}
				var chosenField = #(0.0,0.0)
				var chosenFieldDist = -1.0
				each(elem in barriers){
					var dist = getDistance(elem.Item1, elem.Item2)
					if((dist < chosenFieldDist) or (chosenFieldDist === -1.0)){
						chosenField = elem
						chosenFieldDist = dist
					}
				}
				
				each(elem in ditches){
					var dist = getDistance(elem.Item1, elem.Item2)
					if((dist < chosenFieldDist) or (chosenFieldDist === -1.0)){
						chosenField = elem
						chosenFieldDist = dist
					}
				}
				
				// IF NO COVER FIELDS KNOWN -> EXPLORE
				var switching = false
				if (debug){println("Evaluating formula: chosenFieldDist: "+chosenFieldDist+"\tenergy: "+energy+"\tenemyCount: "+enemyCount)}
				if(chosenFieldDist > energy/(enemyCount*10)){
					if (debug){println("Formula true -> exploring...")}
					exploreEnv("barriers")
					exploreEnv("hills")
					exploreEnv("ditches")
					
					each(elem in barriers){
						var dist = getDistance(elem.Item1, elem.Item2)
						if((dist < chosenFieldDist) or (chosenFieldDist === -1.0)){
							chosenField = elem
							chosenFieldDist = dist
						}
					}
					
					each(elem in ditches){
						var dist = getDistance(elem.Item1, elem.Item2)
						if((dist < chosenFieldDist) or (chosenFieldDist === -1.0)){
							chosenField = elem
							chosenFieldDist = dist
						}
					}
				
				} else {
					if (debug){println("Formula false -> MoveToAndShoot...")}
					// setting switch to go to next else if branch MoveToAndShoot
					switching = true
				}
				
				
				// IF STILL NO COVER IS REACHABLE			
				if(chosenFieldDist > energy/(enemyCount * 10)){
					state = 10
				}else if(switching){
					if (debug){println("Going to cover " + chosenField.Item1 + " | " + chosenField.Item2)}
					var target : Tuple<real, real> = nil
					var cdist = -1.0
					for(var i = 0; i < enemiesFromTeam.Size(); i++){
						var coord = enemiesFromTeam.Get(i)
						var d = getDistance(coord.Item1, coord.Item2)
						if(d >= 0 and (cdist === -1.0 or d < cdist)){
							target = coord
							cdist = d
						}
					}
					
					xpos = target.Item1 as integer
					ypos = target.Item2 as integer
	
					state = 3
				}
			}
			
			// stage 3
			// *********************************************************************
			// MOVETOANDSHOOT
			if(state === 3){
				var statechange = false
				if (debug){println("Entering MoveToAndShoot")}
				// set closest enemy as target
				if (debug){println("tagging " + xpos + " | " + ypos)}
				if(hasBeeline(xpos, ypos)){
					while(actionPoints > 4){
						var hit = taggedCounter
						tag(xpos as real, ypos as real)
						
						if(hit !== taggedCounter){
							arg1 = 0
						}else{
							arg1++
						}
					}
				}else{
					state = 0
					xpos = xcor as integer
					ypos = ycor as integer
					arg1 = 0
					arg2 = 0
					arg3 = 0
					arg4 = 0
				}
				if(not statechange){
					var chosenField = #(0.0,0.0)
					var chosenFieldDist = -1.0
					each(elem in barriers){
						var dist = getDistance(elem.Item1, elem.Item2)
						if((dist < chosenFieldDist) or (chosenFieldDist === -1.0)){
							chosenField = elem
							chosenFieldDist = dist
						}
					}
					
					each(elem in ditches){
						var dist = getDistance(elem.Item1, elem.Item2)
						if((dist < chosenFieldDist) or (chosenFieldDist === -1.0)){
							chosenField = elem
							chosenFieldDist = dist
						}
					}
					var x = chosenField.Item1
					var y = chosenField.Item2
					
					if(arg1 < 3){
						// goTo(real, real)
						if (debug){println("going to x: " + x + "  y: " + y)}
						var reached : bool
						if (battleground.GetIntegerValue(x,y) !== 1) {
							reached = goTo(x as real,y as real)
						}else{
							// if chosenField is a barrier, choose one of its neighbor fields, which isn't a barrier
							// and is closer to the agent itself
							var breaking = false
							for (var xi = chosenField.Item1 - 1.0; xi <= chosenField.Item1 + 1.0; xi++) {
								for (var yi = chosenField.Item2 - 1.0; yi <= chosenField.Item2 + 1.0; yi++) {
									if ((battleground.GetIntegerValue(xi, yi) !== 1) and (getDistance(xi,yi) < getDistance(chosenField.Item1,chosenField.Item2)) and (not breaking)){
										reached = goTo(Math.Min(battleground.DimensionX - 1, Math.Max(0, xi)) as real, Math.Min(battleground.DimensionY - 1, Math.Max(0, yi)) as real)
										xpos = xi as integer
										ypos = yi as integer
										breaking = true
									}
								}
							}
						}
						
						if(reached){
							if (debug){println("reached cover field")}
							state = 1
						}
					}else{
						if (debug){println("missed too often")}
						state = 1
					}
				}
				
			}
			
			// stage 10
			if(state === 10){
				var c : Tuple<real, real> = nil
				var cdist = -1.0
				for(var i = 0; i < enemiesFromTeam.Size(); i++){
					var coord = enemiesFromTeam.Get(i)
					var d = getDistance(coord.Item1, coord.Item2)
					if(d >= 0 and (cdist === -1.0 or d < cdist)){
						c = coord
						cdist = d
					}
				}
				if(c === nil){
					state = 1
					xpos = xSpawn as integer
					ypos = ySpawn as integer
					arg1 = 0
					arg2 = 0
					arg3 = 0
					arg4 = 0
				}else{
					state = 11
					xpos = c.Item1 as integer
					ypos = c.Item2 as integer
					arg1 = 0
					arg2 = 0
					arg3 = 0
					arg4 = 0
				}
			}
			
			// stage 11-20
			// arg 1: misses 2: addedcounter
			if(state > 10 and state <= 20){
                changeStance("lying")
                if((arg1 > 1) or (not hasBeeline(xpos,ypos))){
                    state = 0
                    xpos = xcor as integer
                    ypos = ycor as integer
                    arg1 = 0
					arg2 = 0
					arg3 = 0
					arg4 = 0
                }else{
                    if(wasTaggedCounter > 0 and false and (battleground.GetIntegerValue(xpos,ypos) !== 1)){
						var nv = #(xcor-(xpos as real),ycor-(ypos as real))
						var nvval = (nv.Item1**2+nv.Item2**2)**0.5
						nv = #(nv.Item1/nvval,nv.Item2/nvval)
						if (debug){println(memberID + " TAG MOVE > " + xcor +";"+ycor+" | "+Math.Round(xcor+nv.Item1)+";"+Math.Round(ycor+nv.Item2))}
                        goTo(Math.Min(battleground.DimensionX - 1, Math.Max(0, Math.Round(xcor+nv.Item1))) as real, Math.Min(battleground.DimensionY - 1, Math.Max(0, Math.Round(ycor+nv.Item2))) as real)
                    }
					if(wasTaggedCounter > 0){
						var cords = #(xcor,ycor)
						var cdist = -1.0 
						each(var xd in #[-1.0,0.0,1.0]){
							each(var yd in #[-1.0,0.0,1.0]){
								var nx = xcor + xd
								var ny = ycor + yd
								var coorddist = (Math.Abs(nx-xpos)**2+Math.Abs(ny-ypos)**2)**0.5
								var coordview = false
								var w : integer = (nx - xpos) as integer
								var h : integer = (ny - ypos) as integer
								var dx1 : integer = 0
								var dy1 : integer = 0
								var dx2 : integer = 0
								var dy2 : integer = 0
								if (w < 0) { dx1 = -1 }
								else if (w > 0) { dx1 = 1 }
								if (h < 0) { dy1 = -1 }
								else if (h > 0) { dy1 = 1 }
								if (w < 0) { dx2 = -1 }
								else if (w > 0) { dx2 = 1 }
								var longest : integer = Math.Abs(w)
								var shortest : integer = Math.Abs(h)
								if (not(longest > shortest)) {
									longest = Math.Abs(h)
									shortest = Math.Abs(w)
									if (h < 0) { dy2 = -1 }
									else if (h > 0) { dy2 = 1 }
									dx2 = 0          
								}
								var numerator : integer = longest / 2
								for (var i=0; i < longest; i++) {
									if ((battleground.GetIntegerValue(nx, ny) === 1) or (battleground.GetIntegerValue(nx, ny) === 2)) {
										coordview = false
										i = longest
									} 
									numerator = numerator + shortest
									if (not (numerator < longest)) {
										numerator = numerator - longest
										nx = nx + dx1
										ny = ny + dy1
									} else {
										nx = nx + dx2
										ny = ny + dy2
									}
								}
								if((battleground.GetIntegerValue(nx,ny) !== 1) and coordview and (cdist < coorddist) and ((nx !== xcor) and (ny !== ycor))){
									cdist = coorddist
									cords = #(nx,ny)
									println(memberID + " TAG MOVE > " + xcor +";"+ycor+" | "+nx+";"+ny)
								}
							}
						}
                        goTo(Math.Min(battleground.DimensionX - 1, Math.Max(0, Math.Round(cords.Item1))) as real, Math.Min(battleground.DimensionY - 1, Math.Max(0, Math.Round(cords.Item2))) as real)
                    }
                    if(magazineCount > 0){
                        var hit = taggedCounter
                        tag(xpos as real,ypos as real)
                        if(hit !== taggedCounter){
                            arg1 = arg1 + 1
                        }else{
                            arg1 = 0
                        }
                    }else{reload()}
                    if(state >= 13){
                        state = 1
                    }else if(arg2 < 9){
                        arg2 = arg2 + 1
                    }else{
                        state = state + 1
                        arg2 = 0
                    }
                }    
            }
			mainloopcount++
		} // while
		var activ = (xcor === oxcor) and (ycor === oycor) and (xcor === xSpawn) and (ycor === ySpawn)
		if(mainloopcount >= 20 or activ){
			if (debug){println("-----------------------------------------------------------------------------------------------------")}
			var tpos = #(xcor,ycor)
			if(random(10) === 0){
				tpos = #(random(battleground.DimensionX) as real, random(battleground.DimensionY) as real)
			}
			var ntpos = tpos
			var i = 0
			while(battleground.GetIntegerValue(ntpos.Item1,ntpos.Item2) === 1){
				ntpos = #(Math.Min(battleground.DimensionX - 1, Math.Max(0, tpos.Item1+random(5)-3)) as real, Math.Min(battleground.DimensionY - 1, Math.Max(0, tpos.Item2+random(5)-3)) as real)
				if(i>30){
					ntpos = #(random(battleground.DimensionX) as real, random(battleground.DimensionY) as real)
					i = 0
				}
				i++
			}
			state = 1
			xpos = ntpos.Item1 as integer
			ypos = ntpos.Item2 as integer
			arg1 = 0
			arg2 = 0
			arg3 = 0
			arg4 = 0
		}
		if((xcor === oxcor) and (ycor === oycor) and (state === 0 or state === 1)){
			if (debug){println("///////////////////////////////////////////////////////////////////////////////////////////////")}
			var ntpos = #(Math.Min(battleground.DimensionX - 1, Math.Max(0, random(battleground.DimensionX))) as real, Math.Min(battleground.DimensionY - 1, Math.Max(0, random(battleground.DimensionY))) as real)
			while(battleground.GetIntegerValue(ntpos.Item1,ntpos.Item2) === 1){
				ntpos = #(Math.Min(battleground.DimensionX - 1, Math.Max(0, random(battleground.DimensionX))) as real, Math.Min(battleground.DimensionY - 1, Math.Max(0, random(battleground.DimensionY))) as real)
			}
			state = 1
			xpos = ntpos.Item1 as integer
			ypos = ntpos.Item2 as integer
			arg1 = 0
			arg2 = 0
			arg3 = 0
			arg4 = 0
		}
		var nxcor = xcor
		var nycor = ycor
		
		reload()
		exploreEnemies()
		exploreEnv("barriers")
		exploreEnv("hills")
		exploreEnv("ditches")
		
		// pack stage
		state = Math.Max(0, Math.Min(20,state))
		xpos = Math.Max(0, Math.Min(99,xpos))
		ypos = Math.Max(0, Math.Min(99,ypos))
		arg1 = Math.Max(0, Math.Min(9,arg1))
		arg2 = Math.Max(0, Math.Min(9,arg2))
		arg3 = Math.Max(0, Math.Min(9,arg3))
		arg4 = Math.Max(0, Math.Min(9,arg4))
		stage = ((state*100000000 + xpos*1000000 + ypos*10000 + arg1*1000 + arg2*100 + arg3*10 + arg4) * vz) as integer
		
		refillPoints()
	} // tick